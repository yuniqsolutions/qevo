class S{debug=!1;listeners={add:new Set,update:new Set,remove:new Set};cleanupIntervalId;CLEANUP_INTERVAL_MS=30000;constructor(){this.initializeCleanup()}addListener(J,X){this.listeners[J].add(X)}removeListener(J,X){this.listeners[J].delete(X)}triggerListeners(J,X,Y,G){try{switch(J){case"add":this.listeners.add.forEach(($)=>$(X,G));break;case"remove":this.listeners.remove.forEach(($)=>$(X));break;case"update":this.listeners.update.forEach(($)=>$(X,Y,G));break}}catch($){if(this.debug)throw console.error(`Error in storage change handler for key ${X}:`,$),$}}initializeCleanup(){if(this.shouldRunCleanup())this.startCleanup()}shouldRunCleanup(){return!0}isServiceWorker(){return typeof self<"u"&&"ServiceWorkerGlobalScope"in self&&self instanceof self.ServiceWorkerGlobalScope}startCleanup(){if(this.cleanupIntervalId)clearInterval(this.cleanupIntervalId);this.cleanupIntervalId=setInterval(()=>{this.cleanupExpired().catch((J)=>{if(this.debug)throw console.error("Cleanup interval error:",J),J})},this.CLEANUP_INTERVAL_MS)}stopCleanup(){if(this.cleanupIntervalId)clearInterval(this.cleanupIntervalId),this.cleanupIntervalId=void 0}destroy(){this.stopCleanup(),this.listeners.add.clear(),this.listeners.update.clear(),this.listeners.remove.clear()}}class I extends S{STORAGE_QUOTA_BYTES=8388608;boundStorageHandler=null;constructor(){super();if(this.isContextValid()&&chrome?.storage?.onChanged)this.boundStorageHandler=this.handleStorageChange.bind(this),chrome.storage.onChanged.addListener(this.boundStorageHandler)}isContextValid(){try{return!!chrome.runtime?.id}catch{return!1}}shouldRunCleanup(){return this.isBackgroundScript()&&!this.isServiceWorker()}async put(J,X,Y){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot set key ${J}: Extension context invalidated`);return}try{let{ttl:G,expires:$}=Y||{},U=G?Date.now()+G*1000:$?$.getTime():void 0,W={value:X,expires:U};await chrome.storage.local.set({[J]:W})}catch(G){if(G.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot set key ${J}: Extension context invalidated`)}else{if(this.debug)console.error(`Failed to set key ${J}:`,G);throw Error(`Storage set operation failed for key ${J}`)}}}async get(J,X){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get key ${J}: Extension context invalidated`);return null}try{if(X){let $=await this.listKeys(J);if($.length===0)return null;J=$[0]}let G=(await chrome.storage.local.get(J))[J];if(!G)return null;if(G.expires&&Date.now()>G.expires)return await this.remove(J),null;return G.value}catch(Y){if(Y.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot get key ${J}: Extension context invalidated`);return null}if(this.debug)console.error(`Failed to get key ${J}:`,Y);return null}}async getWithMetadata(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get metadata for key ${J}: Extension context invalidated`);return null}try{let Y=(await chrome.storage.local.get(J))[J];if(!Y)return null;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),null;return Y}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot get metadata for key ${J}: Extension context invalidated`);return null}if(this.debug)console.error(`Failed to get metadata for key ${J}:`,X);return null}}async has(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot check key ${J}: Extension context invalidated`);return!1}try{let Y=(await chrome.storage.local.get(J))[J];if(!Y)return!1;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),!1;return!0}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot check key ${J}: Extension context invalidated`);return!1}if(this.debug)console.error(`Failed to check key ${J}:`,X);return!1}}async remove(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot remove key ${J}: Extension context invalidated`);return}try{await chrome.storage.local.remove(J)}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot remove key ${J}: Extension context invalidated`)}else if(this.debug)console.error(`Failed to remove key ${J}:`,X)}}async length(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage length: Extension context invalidated");return 0}try{let J=await chrome.storage.local.get(null);return Object.keys(J).length}catch(J){if(J.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot get storage length: Extension context invalidated");return 0}if(this.debug)console.error("Failed to get storage length:",J);return 0}}async listKeys(J=""){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return[]}try{let X=await chrome.storage.local.get(null);return Object.keys(X).filter((Y)=>J.length>0?Y.startsWith(J):!0)}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return[]}if(this.debug)console.error("Failed to list keys:",X);return[]}}async getKeyByPrefix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await chrome.storage.local.get(null);return Object.keys(X).find((Y)=>Y.startsWith(J))}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}if(this.debug)console.error("Failed to list keys:",X);return}}async getKeyBySuffix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await chrome.storage.local.get(null);return Object.keys(X).find((Y)=>Y.endsWith(J))}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}if(this.debug)console.error("Failed to list keys:",X);return}}async batch(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch operations: Extension context invalidated");return J.map(()=>{return})}try{let X=[],Y={},G=[];for(let $ of J)switch($.type){case"set":if($.value!==void 0){let W=$.ttl?Date.now()+$.ttl*1000:$.expires?$.expires.getTime():void 0;Y[$.key]={value:$.value,expires:W}}X.push(void 0);break;case"remove":G.push($.key),X.push(void 0);break;case"get":let U=await this.get($.key);X.push(U);break}if(Object.keys(Y).length>0){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch set: Extension context invalidated");return J.map(()=>{return})}await chrome.storage.local.set(Y)}if(G.length>0){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch remove: Extension context invalidated");return J.map(()=>{return})}try{await chrome.storage.local.remove(G)}catch($){if($.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot perform batch remove: Extension context invalidated");return J.map(()=>{return})}throw $}}return X}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot perform batch operations: Extension context invalidated");return J.map(()=>{return})}if(this.debug)console.error("Batch operation failed:",X);if(this.debug)throw Error("Batch operation failed");else return J.map(()=>{return})}}async getStorageUsage(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage usage: Extension context invalidated");return 0}try{return await chrome.storage.local.getBytesInUse()}catch(J){if(J.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot get storage usage: Extension context invalidated");return 0}if(this.debug)console.error("Failed to get storage usage:",J);return 0}}async cleanupExpired(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");this.stopCleanup();return}try{let J=await chrome.storage.local.get(null),X=Date.now(),Y=[];for(let G in J){let $=J[G];if($?.expires&&X>$.expires)Y.push(G)}if(Y.length>0){if(!this.isContextValid()){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");return}await chrome.storage.local.remove(Y)}}catch(J){if(J.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");this.stopCleanup()}else if(this.debug)throw console.error("Failed to clean up expired keys:",J),J}}handleStorageChange(J,X){if(X!=="local"||!this.isContextValid())return;for(let[Y,{oldValue:G,newValue:$}]of Object.entries(J))if(G===void 0&&$!==void 0)this.triggerListeners("add",Y,void 0,$?.value||$);else if($===void 0&&G!==void 0)this.triggerListeners("remove",Y);else if(G!==void 0&&$!==void 0)this.triggerListeners("update",Y,G?.value||G,$?.value||$)}isBackgroundScript(){try{return!!chrome.runtime?.getManifest()?.background}catch{return!1}}destroy(){if(this.boundStorageHandler&&chrome?.storage?.onChanged){try{chrome.storage.onChanged.removeListener(this.boundStorageHandler)}catch(J){if(this.debug)console.error("Failed to remove storage listener:",J)}this.boundStorageHandler=null}super.destroy()}}class l extends S{boundStorageHandler=null;constructor(){super();if(this.isContextValid()&&browser?.storage?.onChanged)this.boundStorageHandler=this.handleStorageChange.bind(this),browser.storage.onChanged.addListener(this.boundStorageHandler)}isContextValid(){try{return typeof browser<"u"&&!!browser.runtime?.id}catch{return!1}}shouldRunCleanup(){return this.isBackgroundScript()&&!this.isServiceWorker()}async put(J,X,Y){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot set key ${J}: Extension context invalidated`);return}try{let{ttl:G,expires:$}=Y||{},U=G?Date.now()+G*1000:$?$.getTime():void 0,W={value:X,expires:U};await browser.storage.local.set({[J]:W})}catch(G){if(this.debug)console.error(`Failed to set key ${J}:`,G);if(this.debug)throw Error(`Storage set operation failed for key ${J}`)}}async get(J,X){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get key ${J}: Extension context invalidated`);return null}try{if(X){let $=await this.listKeys(J);if($.length===0)return null;J=$[0]}let G=(await browser.storage.local.get(J))[J];if(!G)return null;if(G.expires&&Date.now()>G.expires)return await this.remove(J),null;return G.value}catch(Y){if(this.debug)console.error(`Failed to get key ${J}:`,Y);return null}}async getWithMetadata(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get metadata for key ${J}: Extension context invalidated`);return null}try{let Y=(await browser.storage.local.get(J))[J];if(!Y)return null;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),null;return Y}catch(X){if(this.debug)console.error(`Failed to get metadata for key ${J}:`,X);return null}}async has(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot check key ${J}: Extension context invalidated`);return!1}try{let Y=(await browser.storage.local.get(J))[J];if(!Y)return!1;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),!1;return!0}catch(X){if(this.debug)console.error(`Failed to check key ${J}:`,X);return!1}}async remove(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot remove key ${J}: Extension context invalidated`);return}try{await browser.storage.local.remove(J)}catch(X){if(this.debug)console.error(`Failed to remove key ${J}:`,X)}}async length(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage length: Extension context invalidated");return 0}try{let J=await browser.storage.local.get(null);return Object.keys(J).length}catch(J){if(this.debug)console.error("Failed to get storage length:",J);return 0}}async listKeys(J=""){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return[]}try{let X=await browser.storage.local.get(null);return Object.keys(X).filter((Y)=>J.length>0?Y.startsWith(J):!0)}catch(X){if(this.debug)console.error("Failed to list keys:",X);return[]}}async getKeyByPrefix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await browser.storage.local.get(null);return Object.keys(X).find((Y)=>Y.startsWith(J))}catch(X){if(this.debug)console.error("Failed to list keys:",X);return}}async getKeyBySuffix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await browser.storage.local.get(null);return Object.keys(X).find((Y)=>Y.endsWith(J))}catch(X){if(this.debug)console.error("Failed to list keys:",X);return}}async batch(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch operations: Extension context invalidated");return J.map(()=>{return})}let X=[];try{let Y={},G=[];for(let $ of J)switch($.type){case"set":if($.value!==void 0){let W=$.ttl?Date.now()+$.ttl*1000:$.expires?$.expires.getTime():void 0;Y[$.key]={value:$.value,expires:W}}X.push(void 0);break;case"remove":G.push($.key),X.push(void 0);break;case"get":let U=await this.get($.key);X.push(U);break}if(Object.keys(Y).length>0)await browser.storage.local.set(Y);if(G.length>0)await browser.storage.local.remove(G);return X}catch(Y){if(this.debug)console.error("Batch operation failed:",Y);if(this.debug)throw Error("Batch operation failed");return X}}async getStorageUsage(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage usage: Extension context invalidated");return 0}try{let J=await browser.storage.local.get(null),X=JSON.stringify(J);return new Blob([X]).size}catch(J){if(this.debug)console.error("Failed to get storage usage:",J);return 0}}async cleanupExpired(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");this.stopCleanup();return}try{let J=await browser.storage.local.get(null),X=Date.now(),Y=[];for(let G in J){let $=J[G];if($?.expires&&X>$.expires)Y.push(G)}if(Y.length>0)await browser.storage.local.remove(Y)}catch(J){if(this.debug)throw console.error("Failed to clean up expired keys:",J),J}}handleStorageChange(J,X){if(X!=="local"||!this.isContextValid())return;for(let[Y,{oldValue:G,newValue:$}]of Object.entries(J))if(G===void 0&&$!==void 0)this.triggerListeners("add",Y,void 0,$?.value||$);else if($===void 0&&G!==void 0)this.triggerListeners("remove",Y);else if(G!==void 0&&$!==void 0)this.triggerListeners("update",Y,G?.value||G,$?.value||$)}isBackgroundScript(){try{return!!browser.runtime?.getManifest()?.background}catch{return!1}}destroy(){if(this.boundStorageHandler&&browser?.storage?.onChanged){try{browser.storage.onChanged.removeListener(this.boundStorageHandler)}catch(J){if(this.debug)console.error("Failed to remove storage listener:",J)}this.boundStorageHandler=null}super.destroy()}}class n extends S{dbName="QevoKVStore";dbVersion=1;storeName="keyvalue";db=null;initPromise=null;constructor(){super();this.initPromise=this.initDB()}isContextValid(){return typeof self<"u"&&"indexedDB"in self}shouldRunCleanup(){return!this.isServiceWorker()&&typeof window<"u"}async initDB(){if(!this.isContextValid())throw Error("IndexedDB not available");return new Promise((J,X)=>{let Y=indexedDB.open(this.dbName,this.dbVersion);Y.onerror=()=>X(Y.error),Y.onsuccess=()=>{this.db=Y.result,J()},Y.onupgradeneeded=(G)=>{let $=G.target.result;if(!$.objectStoreNames.contains(this.storeName))$.createObjectStore(this.storeName)}})}async ensureDB(){if(this.initPromise)await this.initPromise;if(!this.db)throw Error("Database not initialized");return this.db}async transaction(J,X){let Y=await this.ensureDB();return new Promise((G,$)=>{let W=Y.transaction([this.storeName],J).objectStore(this.storeName),Z=X(W);Z.onsuccess=()=>G(Z.result),Z.onerror=()=>$(Z.error)})}async put(J,X,Y){let{ttl:G,expires:$}=Y||{},U=G?Date.now()+G*1000:$?$.getTime():void 0,W={value:X,expires:U},Z=await this.getWithMetadata(J);if(await this.transaction("readwrite",(z)=>z.put(W,J)),Z===null)this.triggerListeners("add",J,void 0,X);else this.triggerListeners("update",J,Z.value,X)}async get(J,X){try{if(X){let G=await this.listKeys(J);if(G.length===0)return null;J=G[0]}let Y=await this.transaction("readonly",(G)=>G.get(J));if(!Y)return null;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),null;return Y.value}catch(Y){if(this.debug)console.error(`Failed to get key ${J}:`,Y);return null}}async getWithMetadata(J){try{let X=await this.transaction("readonly",(Y)=>Y.get(J));if(!X)return null;if(X.expires&&Date.now()>X.expires)return await this.remove(J),null;return X}catch(X){if(this.debug)console.error(`Failed to get metadata for key ${J}:`,X);return null}}async has(J){try{let X=await this.transaction("readonly",(Y)=>Y.get(J));if(!X)return!1;if(X.expires&&Date.now()>X.expires)return await this.remove(J),!1;return!0}catch(X){if(this.debug)console.error(`Failed to check key ${J}:`,X);return!1}}async remove(J){try{await this.transaction("readwrite",(X)=>X.delete(J)),this.triggerListeners("remove",J)}catch(X){if(this.debug)console.error(`Failed to remove key ${J}:`,X)}}async length(){try{return await this.transaction("readonly",(J)=>J.count())}catch(J){if(this.debug)console.error("Failed to get storage length:",J);return 0}}async listKeys(J=""){try{let X=await this.ensureDB();return new Promise((Y,G)=>{let W=X.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();W.onsuccess=()=>{let Z=W.result,z=J.length>0?Z.filter((D)=>D.startsWith(J)):Z;Y(z)},W.onerror=()=>G(W.error)})}catch(X){if(this.debug)console.error("Failed to list keys:",X);return[]}}async getKeyByPrefix(J){let X=await this.listKeys(J);return X.length>0?X[0]:void 0}async getKeyBySuffix(J){return(await this.listKeys()).find((Y)=>Y.endsWith(J))}async batch(J){let X=[];try{for(let Y of J)switch(Y.type){case"set":if(Y.value!==void 0)await this.put(Y.key,Y.value,{ttl:Y.ttl,expires:Y.expires});X.push(void 0);break;case"remove":await this.remove(Y.key),X.push(void 0);break;case"get":let G=await this.get(Y.key);X.push(G);break}return X}catch(Y){if(this.debug)console.error("Batch operation failed:",Y);if(this.debug)throw Error("Batch operation failed");return X}}async getStorageUsage(){try{let J=await this.ensureDB();return new Promise((X,Y)=>{let U=J.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();U.onsuccess=()=>{let W=U.result,Z=JSON.stringify(W),z=new Blob([Z]).size;X(z)},U.onerror=()=>Y(U.error)})}catch(J){if(this.debug)console.error("Failed to get storage usage:",J);return 0}}async cleanupExpired(){try{let J=await this.ensureDB(),X=Date.now(),Y=[];if(await new Promise((G,$)=>{let Z=J.transaction([this.storeName],"readonly").objectStore(this.storeName).openCursor();Z.onsuccess=(z)=>{let D=z.target.result;if(D){let K=D.value;if(K?.expires&&X>K.expires)Y.push(D.key);D.continue()}else G()},Z.onerror=()=>$(Z.error)}),Y.length>0){let $=J.transaction([this.storeName],"readwrite").objectStore(this.storeName);for(let U of Y)$.delete(U)}}catch(J){if(this.debug)throw console.error("Failed to clean up expired keys:",J),J}}destroy(){if(this.db){try{this.db.close()}catch(J){if(this.debug)console.error("Failed to close IndexedDB connection:",J)}this.db=null}this.initPromise=null,super.destroy()}}function o(){if(typeof chrome<"u"&&chrome.runtime&&chrome.storage)return new I;if(typeof browser<"u"&&browser.runtime&&browser.storage)return new l;if(typeof window<"u"&&"indexedDB"in window)return new n;throw Error("No suitable storage backend available")}var a=o();var H=typeof browser<"u"&&typeof browser.runtime<"u",M=H?browser:chrome;class h{_debug=!1;constructor(J=!1){this._debug=J}set debug(J){this._debug=J}get debug(){return this._debug}log(...J){if(this._debug)console.log("[QevoTabs]",...J)}error(...J){if(this._debug)console.error("[QevoTabs]",...J)}async create(J){try{if(H)return await M.tabs.create(J);else return await M.tabs.create(J)}catch(X){throw this.error("Error creating tab:",X),X}}async get(J){try{if(H)return await M.tabs.get(J);else return await M.tabs.get(J)}catch(X){throw this.error("Error getting tab:",X),X}}async getCurrent(){try{if(H){let J=await M.tabs.getCurrent();if(!J)throw Error("No current tab found");return J}else{let J=await M.tabs.getCurrent();if(!J)throw Error("No current tab found");return J}}catch(J){throw this.error("Error getting current tab:",J),J}}async query(J){try{if(H)return await M.tabs.query(J);else return await M.tabs.query(J)}catch(X){throw this.error("Error querying tabs:",X),X}}async update(J,X){try{if(typeof J==="number")if(H){let Y=await M.tabs.update(J,X);if(!Y)throw Error("Failed to update tab");return Y}else{let Y=await M.tabs.update(J,X);if(!Y)throw Error("Failed to update tab");return Y}else if(H){let Y=await M.tabs.update(J);if(!Y)throw Error("Failed to update tab");return Y}else{let Y=await M.tabs.update(J);if(!Y)throw Error("Failed to update tab");return Y}}catch(Y){throw this.error("Error updating tab:",Y),Y}}async remove(J){try{if(H)if(Array.isArray(J))await M.tabs.remove(J);else await M.tabs.remove(J);else if(Array.isArray(J))await M.tabs.remove(J);else await M.tabs.remove(J)}catch(X){throw this.error("Error removing tab:",X),X}}async duplicate(J){try{if(H)return await M.tabs.duplicate(J);else return await M.tabs.duplicate(J)}catch(X){throw this.error("Error duplicating tab:",X),X}}async move(J,X){try{if(H)if(Array.isArray(J))return await M.tabs.move(J,X);else return await M.tabs.move(J,X);else if(Array.isArray(J))return await M.tabs.move(J,X);else return await M.tabs.move(J,X)}catch(Y){throw this.error("Error moving tab:",Y),Y}}async reload(J,X){try{if(H)if(J!==void 0)await M.tabs.reload(J,X);else await M.tabs.reload(X);else if(J!==void 0)await M.tabs.reload(J,X);else await M.tabs.reload(X)}catch(Y){throw this.error("Error reloading tab:",Y),Y}}async highlight(J){try{if(H)return await M.tabs.highlight(J);else return await M.tabs.highlight(J)}catch(X){throw this.error("Error highlighting tabs:",X),X}}async discard(J){try{if(H)if(J!==void 0)return await M.tabs.discard(J),await M.tabs.get(J);else throw Error("Firefox requires a tabId for discard()");else if(J!==void 0)return await M.tabs.discard(J);else return await M.tabs.discard()}catch(X){throw this.error("Error discarding tab:",X),X}}async getZoom(J){try{if(H)if(J!==void 0)return await M.tabs.getZoom(J);else return await M.tabs.getZoom();else if(J!==void 0)return await M.tabs.getZoom(J);else return await M.tabs.getZoom()}catch(X){throw this.error("Error getting zoom:",X),X}}async setZoom(J,X){try{if(typeof X==="number")if(H)if(J!==void 0)await M.tabs.setZoom(J,X);else await M.tabs.setZoom(X);else if(J!==void 0)await M.tabs.setZoom(J,X);else await M.tabs.setZoom(X);else if(H)await M.tabs.setZoom(J);else await M.tabs.setZoom(J)}catch(Y){throw this.error("Error setting zoom:",Y),Y}}async getZoomSettings(J){try{if(H)return await M.tabs.getZoomSettings(J);else return await M.tabs.getZoomSettings(J)}catch(X){throw this.error("Error getting zoom settings:",X),X}}async setZoomSettings(J,X){try{if(X)if(H)return await M.tabs.setZoomSettings(J,X);else return await M.tabs.setZoomSettings(J,X);else if(H)return await M.tabs.setZoomSettings(J);else return await M.tabs.setZoomSettings(J)}catch(Y){throw this.error("Error setting zoom settings:",Y),Y}}async getAll(){return this.query({})}async getAllInCurrentWindow(){return this.query({currentWindow:!0})}async getActive(){let[J]=await this.query({active:!0,currentWindow:!0});return J}async findByUrl(J){return(await this.getAll()).find((Y)=>Y.url===J||Y.url?.includes(J))}async findByTitle(J){return(await this.getAll()).find((Y)=>Y.title?.toLowerCase().includes(J.toLowerCase()))}async goBack(J){try{if(H)await M.tabs.goBack(J);else await M.tabs.goBack(J)}catch(X){throw this.error("Error navigating back:",X),X}}async goForward(J){try{if(H)await M.tabs.goForward(J);else await M.tabs.goForward(J)}catch(X){throw this.error("Error navigating forward:",X),X}}async group(J){try{if(H)throw Error("Tab groups are not supported in Firefox");else return await M.tabs.group(J)}catch(X){throw this.error("Error grouping tabs:",X),X}}async ungroup(J){try{if(H)throw Error("Tab groups are not supported in Firefox");else if(Array.isArray(J))await M.tabs.ungroup(J);else await M.tabs.ungroup(J)}catch(X){throw this.error("Error ungrouping tabs:",X),X}}async captureVisibleTab(J,X){try{let Y,G;if(typeof J==="number")Y=J,G=X;else G=J;if(H)if(Y!==void 0)return await M.tabs.captureVisibleTab(Y,G);else return await M.tabs.captureVisibleTab(G);else if(Y!==void 0)return await M.tabs.captureVisibleTab(Y,G);else return await M.tabs.captureVisibleTab(G)}catch(Y){throw this.error("Error capturing visible tab:",Y),Y}}async detectLanguage(J){try{if(H)return await M.tabs.detectLanguage(J);else return await M.tabs.detectLanguage(J)}catch(X){throw this.error("Error detecting language:",X),X}}connect(J,X){try{if(H)return M.tabs.connect(J,X);else return M.tabs.connect(J,X)}catch(Y){throw this.error("Error connecting to tab:",Y),Y}}async sendMessage(J,X,Y){try{if(H)if(Y!==void 0)return await M.tabs.sendMessage(J,X,Y);else return await M.tabs.sendMessage(J,X);else if(Y!==void 0)return await M.tabs.sendMessage(J,X,Y);else return await M.tabs.sendMessage(J,X)}catch(G){throw this.error("Error sending message to tab:",G),G}}async getUrl(J){try{return(await this.get(J)).url}catch(X){this.error("Error getting tab URL:",X);return}}async getTitle(J){try{return(await this.get(J)).title}catch(X){this.error("Error getting tab title:",X);return}}async getFavIcon(J){try{return(await this.get(J)).favIconUrl}catch(X){this.error("Error getting tab favicon:",X);return}}async getWindow(J){try{return(await this.get(J)).windowId}catch(X){throw this.error("Error getting tab window:",X),X}}onActivated={addListener:(J)=>{M.tabs.onActivated.addListener(J)},removeListener:(J)=>{M.tabs.onActivated.removeListener(J)},hasListener:(J)=>{return M.tabs.onActivated.hasListener(J)}};onAttached={addListener:(J)=>{M.tabs.onAttached.addListener(J)},removeListener:(J)=>{M.tabs.onAttached.removeListener(J)},hasListener:(J)=>{return M.tabs.onAttached.hasListener(J)}};onCreated={addListener:(J)=>{M.tabs.onCreated.addListener(J)},removeListener:(J)=>{M.tabs.onCreated.removeListener(J)},hasListener:(J)=>{return M.tabs.onCreated.hasListener(J)}};onDetached={addListener:(J)=>{M.tabs.onDetached.addListener(J)},removeListener:(J)=>{M.tabs.onDetached.removeListener(J)},hasListener:(J)=>{return M.tabs.onDetached.hasListener(J)}};onHighlighted={addListener:(J)=>{M.tabs.onHighlighted.addListener(J)},removeListener:(J)=>{M.tabs.onHighlighted.removeListener(J)},hasListener:(J)=>{return M.tabs.onHighlighted.hasListener(J)}};onMoved={addListener:(J)=>{M.tabs.onMoved.addListener(J)},removeListener:(J)=>{M.tabs.onMoved.removeListener(J)},hasListener:(J)=>{return M.tabs.onMoved.hasListener(J)}};onRemoved={addListener:(J)=>{M.tabs.onRemoved.addListener(J)},removeListener:(J)=>{M.tabs.onRemoved.removeListener(J)},hasListener:(J)=>{return M.tabs.onRemoved.hasListener(J)}};onReplaced={addListener:(J)=>{M.tabs.onReplaced.addListener(J)},removeListener:(J)=>{M.tabs.onReplaced.removeListener(J)},hasListener:(J)=>{return M.tabs.onReplaced.hasListener(J)}};onUpdated={addListener:(J)=>{M.tabs.onUpdated.addListener(J)},removeListener:(J)=>{M.tabs.onUpdated.removeListener(J)},hasListener:(J)=>{return M.tabs.onUpdated.hasListener(J)}};onZoomChange={addListener:(J)=>{M.tabs.onZoomChange.addListener(J)},removeListener:(J)=>{M.tabs.onZoomChange.removeListener(J)},hasListener:(J)=>{return M.tabs.onZoomChange.hasListener(J)}}}var B=typeof browser<"u"&&browser.runtime,_=B?browser:chrome;function T(){if(typeof process<"u"&&process.env)return!0;if(typeof __webpack_require__<"u")try{if(process.env?.NODE_ENV!=="production")return!0}catch{}if(typeof globalThis<"u"){if(globalThis.__DEV__)return!0;if(globalThis.DEBUG)return!0}return!1}class E{_debug=!1;constructor(J){this._debug=J??T()}set debug(J){this._debug=J}get debug(){return this._debug}log(J,...X){if(this._debug)console.log(`[${J}]`,...X)}error(J,...X){if(this._debug)console.error(`[${J}]`,...X)}warn(J,...X){if(this._debug)console.warn(`[${J}]`,...X)}}function V(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}function r(J,X="Operation timed out"){return new Promise((Y,G)=>{setTimeout(()=>G(Error(X)),J)})}async function i(J,X,Y){return Promise.race([J,r(X,Y)])}function t(J){return new Promise((X)=>setTimeout(X,J))}class O extends E{cookieChangeListeners=new Set;browserListenerInitialized=!1;constructor(J=!1){super(J)}async get(J){try{if(B)return await _.cookies.get(J);else return await _.cookies.get(J)}catch(X){return this.error("QevoCookies","Error getting cookie:",X),null}}async getAll(J){try{if(B)return await _.cookies.getAll(J);else return await _.cookies.getAll(J)}catch(X){return this.error("QevoCookies","Error getting all cookies:",X),[]}}async set(J){try{if(B)return await _.cookies.set(J);else return await _.cookies.set(J)}catch(X){return this.error("QevoCookies","Error setting cookie:",X),null}}async remove(J){try{if(B)await _.cookies.remove(J);else await _.cookies.remove(J);return J}catch(X){throw this.error("QevoCookies","Error removing cookie:",X),X}}async getAllCookieStores(){try{if(B)return await _.cookies.getAllCookieStores();else return await _.cookies.getAllCookieStores()}catch(J){return this.error("QevoCookies","Error getting cookie stores:",J),[]}}addListener(J){if(!this.cookieChangeListeners.has(J)){if(this.cookieChangeListeners.add(J),this.cookieChangeListeners.size===1&&!this.browserListenerInitialized)this.initializeBrowserListener()}}removeListener(J){this.cookieChangeListeners.delete(J)}hasListener(J){return this.cookieChangeListeners.has(J)}initializeBrowserListener(){if(this.browserListenerInitialized)return;let J=(X)=>{this.cookieChangeListeners.forEach((Y)=>{try{Y(X)}catch(G){this.error("QevoCookies","Error in cookie change listener:",G)}})};if(B)_.cookies.onChanged.addListener(J);else _.cookies.onChanged.addListener(J);this.browserListenerInitialized=!0}get api(){return{get:this.get.bind(this),getAll:this.getAll.bind(this),set:this.set.bind(this),remove:this.remove.bind(this),getAllCookieStores:this.getAllCookieStores.bind(this),onChanged:{addListener:this.addListener.bind(this),removeListener:this.removeListener.bind(this),hasListener:this.hasListener.bind(this)}}}}class q extends E{messageListeners=new Map;listenerInitialized=!1;constructor(J=!1){super(J);this.initializeGlobalListener()}initializeGlobalListener(){if(this.listenerInitialized)return;_.runtime.onMessage.addListener((J,X,Y)=>{let{type:G,data:$,id:U,timestamp:W}=J,Z=Date.now();if(!G)return Y(this.createErrorResponse("Message type is required",U,Z-(W||Z))),!1;let z=this.messageListeners.get(G);if(!z||z.length===0)return Y(this.createErrorResponse(`No listeners registered for message type: ${G}`,U,Z-(W||Z))),!1;let D=!1,K=(C)=>{if(!D){D=!0;let N=Date.now()-Z;Y(this.createSuccessResponse(C,U,N))}};try{let C=z[0],N=C.constructor.name==="AsyncFunction",Q=C($,X,K);if(Q&&typeof Q==="object"&&typeof Q.then==="function")return Q.then(()=>{}).catch((j)=>{if(this.error("QevoMessages","Error in async message listener:",j),!D){let s=Date.now()-Z;Y(this.createErrorResponse(j instanceof Error?j.message:"Unknown error in message listener",U,s))}}),!0;if(Q===!0)return!0;if(N)return!0;return!1}catch(C){if(this.error("QevoMessages","Error in message listener:",C),!D){let N=Date.now()-Z;Y(this.createErrorResponse(C instanceof Error?C.message:"Unknown error in message listener",U,N))}return!1}}),this.listenerInitialized=!0}on(J,X){if(!this.messageListeners.has(J))this.messageListeners.set(J,[]);this.messageListeners.get(J).push(X)}off(J,X){let Y=this.messageListeners.get(J);if(Y){let G=Y.indexOf(X);if(G>-1)Y.splice(G,1);if(Y.length===0)this.messageListeners.delete(J)}}clear(J){let X=this.messageListeners.get(J);if(X)X.length=0,this.messageListeners.delete(J)}getTypes(){return Array.from(this.messageListeners.keys())}hasListeners(J){let X=this.messageListeners.get(J);return!!(X&&X.length>0)}async sendToBackground(J,X,Y={}){let G=V(),$={type:J,data:X,id:G,timestamp:Date.now()};return this.sendWithRetry(()=>{if(B)return _.runtime.sendMessage($);else return _.runtime.sendMessage($)},Y,G)}async sendToTab(J,X,Y,G={}){let $=V(),U={type:X,data:Y,id:$,timestamp:Date.now()};return this.sendWithRetry(()=>_.tabs.sendMessage(J,U),G,$)}async sendToAllTabs(J,X,Y={}){try{let $=(await _.tabs.query({})).map((U)=>{if(U.id)return this.sendToTab(U.id,J,X,Y).catch((W)=>this.createErrorResponse(W.message,void 0,0));return Promise.resolve(this.createErrorResponse("Tab has no ID",void 0,0))});return Promise.all($)}catch(G){return this.error("QevoMessages","Error sending to all tabs:",G),[this.createErrorResponse(G instanceof Error?G.message:"Failed to send to all tabs",void 0,0)]}}async broadcast(J,X,Y={}){return this.sendToAllTabs(J,X,Y)}async sendMessage(J,X,Y,G,$){if(J==="background"){let U=X,W=Y,Z=G;return this.sendToBackground(U,W,Z)}if(J==="tab"){let U=X,W=Y,Z=G;return this.sendToTab(U,W,Z,$)}if(J==="tabs"){let U=X,W=Y,Z=G;return this.sendToAllTabs(U,W,Z)}throw Error(`Invalid target: ${J}. Must be 'background', 'tab', or 'tabs'.`)}async sendWithRetry(J,X,Y){let{timeout:G=5000,retries:$=0,retryDelay:U=1000}=X,W=Date.now(),Z=null;for(let D=0;D<=$;D++)try{return await i(J(),G,"Message timeout")}catch(K){if(Z=K instanceof Error?K:Error(String(K)),D<$)await t(U)}let z=Date.now()-W;return this.createErrorResponse(Z?.message||"Failed to send message after retries",Y,z)}createSuccessResponse(J,X,Y=0){return{success:!0,data:J,timestamp:Date.now(),messageId:X||V(),duration:Y}}createErrorResponse(J,X,Y=0){return{success:!1,error:J,timestamp:Date.now(),messageId:X||V(),duration:Y}}}class F extends E{webRequestListeners=new Map;simpleWebRequestListeners=new Map;maxListeners=10;constructor(J=!1){super(J)}on(J,X,Y,G){let U={BeforeRequest:"onBeforeRequest",BeforeSendHeaders:"onBeforeSendHeaders",SendHeaders:"onSendHeaders",HeadersReceived:"onHeadersReceived",AuthRequired:"onAuthRequired",ResponseStarted:"onResponseStarted",BeforeRedirect:"onBeforeRedirect",Completed:"onCompleted",ErrorOccurred:"onErrorOccurred"}[J];if(!U)throw Error(`Unsupported event type: ${J}`);if(!this.simpleWebRequestListeners.has(J))this.simpleWebRequestListeners.set(J,new Set);this.simpleWebRequestListeners.get(J).add(X),this.addListener(U,X,Y,G)}off(J,X){let G={BeforeRequest:"onBeforeRequest",BeforeSendHeaders:"onBeforeSendHeaders",SendHeaders:"onSendHeaders",HeadersReceived:"onHeadersReceived",AuthRequired:"onAuthRequired",ResponseStarted:"onResponseStarted",BeforeRedirect:"onBeforeRedirect",Completed:"onCompleted",ErrorOccurred:"onErrorOccurred"}[J];if(!G)throw Error(`Unsupported event type: ${J}`);let $=this.simpleWebRequestListeners.get(J);if($&&$.has(X)){if($.delete(X),$.size===0)this.simpleWebRequestListeners.delete(J)}this.removeListener(G,X)}clear(J){let X=this.simpleWebRequestListeners.get(J);if(X){let Y=Array.from(X);for(let G of Y)this.off(J,G);X.clear()}}isAvailable(){try{return!!_.webRequest}catch{return!1}}getMaxListeners(){return this.maxListeners}setMaxListeners(J){this.maxListeners=J}addListener(J,X,Y,G){try{if(!this.isAvailable())throw Error("WebRequest API is not available in this context");let $=this.convertFilter(Y),U=this.convertExtraInfoSpec(G);if(!this.webRequestListeners.has(J))this.webRequestListeners.set(J,new Set);if(this.webRequestListeners.get(J).add(X),B){let W=_;if(W.webRequest&&W.webRequest[J])W.webRequest[J].addListener(X,$,U)}else{let W=_;if(W.webRequest&&W.webRequest[J])W.webRequest[J].addListener(X,$,U)}}catch($){throw this.error("QevoWebRequest",`Error adding listener for ${J}:`,$),$}}removeListener(J,X){try{let Y=this.webRequestListeners.get(J);if(Y&&Y.has(X))if(Y.delete(X),B){let G=_;if(G.webRequest&&G.webRequest[J])G.webRequest[J].removeListener(X)}else{let G=_;if(G.webRequest&&G.webRequest[J])G.webRequest[J].removeListener(X)}}catch(Y){throw this.error("QevoWebRequest",`Error removing listener for ${J}:`,Y),Y}}convertFilter(J){if(B){let X={urls:J.urls};if(J.types)X.types=J.types;if(J.tabId!==void 0)X.tabId=J.tabId;if(J.windowId!==void 0)X.windowId=J.windowId;return X}return J}convertExtraInfoSpec(J){if(!J)return;if(B)return J.map((X)=>{switch(X){case"asyncBlocking":return"blocking";case"extraHeaders":return"extraHeaders";default:return X}}).filter(Boolean);return J}get api(){return{on:this.on.bind(this),off:this.off.bind(this),clear:this.clear.bind(this),isAvailable:this.isAvailable.bind(this),getMaxListeners:this.getMaxListeners.bind(this)}}}class x extends E{alarmListeners=new Set;browserListenerInitialized=!1;constructor(J=!1){super(J)}async create(J,X){try{let Y,G;if(typeof J==="string")Y=J,G=X;else Y=void 0,G=J;if(B)if(Y!==void 0)await _.alarms.create(Y,G);else await _.alarms.create(G);else if(Y!==void 0)await _.alarms.create(Y,G);else await _.alarms.create(G)}catch(Y){throw this.error("QevoAlarms","Error creating alarm:",Y),Y}}async get(J){try{if(B)if(J!==void 0)return await _.alarms.get(J);else return await _.alarms.get();else if(J!==void 0)return await _.alarms.get(J);else return await _.alarms.get()}catch(X){this.error("QevoAlarms","Error getting alarm:",X);return}}async getAll(){try{if(B)return await _.alarms.getAll();else return await _.alarms.getAll()}catch(J){return this.error("QevoAlarms","Error getting all alarms:",J),[]}}async clear(J){try{if(B)if(J!==void 0)return await _.alarms.clear(J);else return await _.alarms.clear();else if(J!==void 0)return await _.alarms.clear(J);else return await _.alarms.clear()}catch(X){return this.error("QevoAlarms","Error clearing alarm:",X),!1}}async clearAll(){try{if(B)return await _.alarms.clearAll();else return await _.alarms.clearAll()}catch(J){return this.error("QevoAlarms","Error clearing all alarms:",J),!1}}onAlarm(J){if(this.alarmListeners.add(J),!this.browserListenerInitialized)this.initializeBrowserListener()}offAlarm(J){this.alarmListeners.delete(J)}isAvailable(){try{return!!_.alarms}catch{return!1}}initializeBrowserListener(){if(this.browserListenerInitialized)return;let J=(X)=>{this.alarmListeners.forEach((Y)=>{try{Y(X)}catch(G){this.error("QevoAlarms","Error in alarm listener:",G)}})};if(B)_.alarms.onAlarm.addListener(J);else _.alarms.onAlarm.addListener(J);this.browserListenerInitialized=!0}}class g extends E{clickedListeners=new Set;buttonClickedListeners=new Set;closedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async create(J,X){try{if(B){let Y={type:J.type==="basic"?"basic":"basic",title:J.title,message:J.message,iconUrl:J.iconUrl};return await _.notifications.create(X||"",Y)}else return await _.notifications.create(X||"",J)}catch(Y){throw this.error("QevoNotifications","Error creating notification:",Y),Y}}async update(J,X){try{if(B)return await _.notifications.update(J,X);else return await _.notifications.update(J,X)}catch(Y){return this.error("QevoNotifications","Error updating notification:",Y),!1}}async clear(J){try{if(B)return await _.notifications.clear(J);else return await _.notifications.clear(J)}catch(X){return this.error("QevoNotifications","Error clearing notification:",X),!1}}async getAll(){try{if(B)return await _.notifications.getAll();else return await _.notifications.getAll()}catch(J){return this.error("QevoNotifications","Error getting all notifications:",J),{}}}onClicked(J){this.clickedListeners.add(J),this.ensureListenersInitialized()}offClicked(J){this.clickedListeners.delete(J)}onButtonClicked(J){this.buttonClickedListeners.add(J),this.ensureListenersInitialized()}offButtonClicked(J){this.buttonClickedListeners.delete(J)}onClosed(J){this.closedListeners.add(J),this.ensureListenersInitialized()}offClosed(J){this.closedListeners.delete(J)}isAvailable(){try{return!!_.notifications}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;let J=(G)=>{this.clickedListeners.forEach(($)=>{try{$(G)}catch(U){this.error("QevoNotifications","Error in clicked listener:",U)}})},X=(G,$)=>{this.buttonClickedListeners.forEach((U)=>{try{U(G,$)}catch(W){this.error("QevoNotifications","Error in button clicked listener:",W)}})},Y=(G,$)=>{this.closedListeners.forEach((U)=>{try{U(G,$)}catch(W){this.error("QevoNotifications","Error in closed listener:",W)}})};if(B){let G=_;G.notifications.onClicked.addListener(J),G.notifications.onClosed.addListener(Y)}else{let G=_;G.notifications.onClicked.addListener(J),G.notifications.onButtonClicked.addListener(X),G.notifications.onClosed.addListener(Y)}this.listenersInitialized=!0}}class k extends E{clickedListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}async create(J){return new Promise((X,Y)=>{try{if(B){let G=_.contextMenus.create(J,()=>{let $=browser.runtime.lastError;if($)Y(Error($.message));else X(J.id||"")});if(G!==void 0)X(G)}else{let G=_.contextMenus.create(J,()=>{let $=chrome.runtime.lastError;if($)Y(Error($.message));else X(J.id||"")});if(G!==void 0&&!J.id)X(G)}}catch(G){this.error("QevoContextMenus","Error creating menu item:",G),Y(G)}})}async update(J,X){return new Promise((Y,G)=>{try{if(B)_.contextMenus.update(J,X),Y();else _.contextMenus.update(J,X,()=>{let $=chrome.runtime.lastError;if($)G(Error($.message));else Y()})}catch($){this.error("QevoContextMenus","Error updating menu item:",$),G($)}})}async remove(J){return new Promise((X,Y)=>{try{if(B)_.contextMenus.remove(J),X();else _.contextMenus.remove(J,()=>{let G=chrome.runtime.lastError;if(G)Y(Error(G.message));else X()})}catch(G){this.error("QevoContextMenus","Error removing menu item:",G),Y(G)}})}async removeAll(){return new Promise((J,X)=>{try{if(B)_.contextMenus.removeAll(),J();else _.contextMenus.removeAll(()=>{let Y=chrome.runtime.lastError;if(Y)X(Error(Y.message));else J()})}catch(Y){this.error("QevoContextMenus","Error removing all menu items:",Y),X(Y)}})}onClicked(J){if(this.clickedListeners.add(J),!this.listenerInitialized)this.initializeBrowserListener()}offClicked(J){this.clickedListeners.delete(J)}isAvailable(){try{return!!_.contextMenus}catch{return!1}}initializeBrowserListener(){if(this.listenerInitialized)return;let J=(X,Y)=>{this.clickedListeners.forEach((G)=>{try{G(X,Y)}catch($){this.error("QevoContextMenus","Error in click listener:",$)}})};if(B)_.contextMenus.onClicked.addListener(J);else _.contextMenus.onClicked.addListener(J);this.listenerInitialized=!0}}class y extends E{constructor(J=!1){super(J)}async executeScript(J){try{if(B)if(_.scripting)return await _.scripting.executeScript(J);else return(await _.tabs.executeScript(J.target.tabId,{file:J.files?.[0],code:J.func?`(${J.func.toString()})(${(J.args||[]).map((Y)=>JSON.stringify(Y)).join(",")})`:void 0,allFrames:J.target.allFrames,frameId:J.target.frameIds?.[0]})).map((Y,G)=>({frameId:J.target.frameIds?.[G]||0,result:Y}));else return await _.scripting.executeScript(J)}catch(X){throw this.error("QevoScripting","Error executing script:",X),X}}async insertCSS(J){try{if(B)if(_.scripting)await _.scripting.insertCSS(J);else await _.tabs.insertCSS(J.target.tabId,{file:J.files?.[0],code:J.css,allFrames:J.target.allFrames,frameId:J.target.frameIds?.[0]});else await _.scripting.insertCSS(J)}catch(X){throw this.error("QevoScripting","Error inserting CSS:",X),X}}async removeCSS(J){try{if(B)if(_.scripting)await _.scripting.removeCSS(J);else this.warn("QevoScripting","removeCSS not supported in Firefox MV2");else await _.scripting.removeCSS(J)}catch(X){throw this.error("QevoScripting","Error removing CSS:",X),X}}async registerContentScripts(J){try{if(B)if(typeof _.scripting?.registerContentScripts==="function")await _.scripting.registerContentScripts(J);else this.warn("QevoScripting","registerContentScripts not available in this Firefox version");else await _.scripting.registerContentScripts(J)}catch(X){throw this.error("QevoScripting","Error registering content scripts:",X),X}}async unregisterContentScripts(J){try{if(B){if(typeof _.scripting?.unregisterContentScripts==="function")await _.scripting.unregisterContentScripts(J)}else await _.scripting.unregisterContentScripts(J)}catch(X){throw this.error("QevoScripting","Error unregistering content scripts:",X),X}}async getRegisteredContentScripts(J){try{if(B){if(typeof _.scripting?.getRegisteredContentScripts==="function")return await _.scripting.getRegisteredContentScripts(J);return[]}else return await _.scripting.getRegisteredContentScripts(J)}catch(X){return this.error("QevoScripting","Error getting registered content scripts:",X),[]}}async updateContentScripts(J){try{if(B){if(typeof _.scripting?.updateContentScripts==="function")await _.scripting.updateContentScripts(J)}else await _.scripting.updateContentScripts(J)}catch(X){throw this.error("QevoScripting","Error updating content scripts:",X),X}}isAvailable(){try{return!!_.scripting}catch{return!1}}}class v extends E{clickedListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}getActionAPI(){if(B){let J=_;return J.action||J.browserAction}else{let J=_;return J.action||J.browserAction}}async setBadgeText(J){try{let X=this.getActionAPI();if(X?.setBadgeText)await X.setBadgeText(J)}catch(X){throw this.error("QevoAction","Error setting badge text:",X),X}}async getBadgeText(J={}){try{let X=this.getActionAPI();if(X?.getBadgeText)return await X.getBadgeText(J);return""}catch(X){return this.error("QevoAction","Error getting badge text:",X),""}}async setBadgeBackgroundColor(J){try{let X=this.getActionAPI();if(X?.setBadgeBackgroundColor)await X.setBadgeBackgroundColor(J)}catch(X){throw this.error("QevoAction","Error setting badge color:",X),X}}async getBadgeBackgroundColor(J={}){try{let X=this.getActionAPI();if(X?.getBadgeBackgroundColor)return await X.getBadgeBackgroundColor(J);return[0,0,0,0]}catch(X){return this.error("QevoAction","Error getting badge color:",X),[0,0,0,0]}}async setBadgeTextColor(J){try{let X=this.getActionAPI();if(X?.setBadgeTextColor)await X.setBadgeTextColor(J)}catch(X){throw this.error("QevoAction","Error setting badge text color:",X),X}}async setIcon(J){try{let X=this.getActionAPI();if(X?.setIcon)await X.setIcon(J)}catch(X){throw this.error("QevoAction","Error setting icon:",X),X}}async setTitle(J){try{let X=this.getActionAPI();if(X?.setTitle)await X.setTitle(J)}catch(X){throw this.error("QevoAction","Error setting title:",X),X}}async getTitle(J={}){try{let X=this.getActionAPI();if(X?.getTitle)return await X.getTitle(J);return""}catch(X){return this.error("QevoAction","Error getting title:",X),""}}async setPopup(J){try{let X=this.getActionAPI();if(X?.setPopup)await X.setPopup(J)}catch(X){throw this.error("QevoAction","Error setting popup:",X),X}}async getPopup(J={}){try{let X=this.getActionAPI();if(X?.getPopup)return await X.getPopup(J);return""}catch(X){return this.error("QevoAction","Error getting popup:",X),""}}async enable(J){try{let X=this.getActionAPI();if(X?.enable)await X.enable(J)}catch(X){throw this.error("QevoAction","Error enabling action:",X),X}}async disable(J){try{let X=this.getActionAPI();if(X?.disable)await X.disable(J)}catch(X){throw this.error("QevoAction","Error disabling action:",X),X}}async isEnabled(J){try{let X=this.getActionAPI();if(X?.isEnabled)return await X.isEnabled(J?{tabId:J}:{});return!0}catch(X){return this.error("QevoAction","Error checking if enabled:",X),!0}}async openPopup(){try{let J=this.getActionAPI();if(J?.openPopup)await J.openPopup()}catch(J){throw this.error("QevoAction","Error opening popup:",J),J}}onClicked(J){if(this.clickedListeners.add(J),!this.listenerInitialized)this.initializeListener()}offClicked(J){this.clickedListeners.delete(J)}isAvailable(){try{return!!this.getActionAPI()}catch{return!1}}initializeListener(){if(this.listenerInitialized)return;let J=(Y)=>{this.clickedListeners.forEach((G)=>{try{G(Y)}catch($){this.error("QevoAction","Error in click listener:",$)}})},X=this.getActionAPI();if(X?.onClicked)X.onClicked.addListener(J);this.listenerInitialized=!0}}class u extends E{focusChangedListeners=new Set;createdListeners=new Set;removedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async create(J){try{if(B)return await _.windows.create(J);else return await _.windows.create(J)}catch(X){throw this.error("QevoWindows","Error creating window:",X),X}}async get(J,X){try{if(B)return await _.windows.get(J,X);else return await _.windows.get(J,X)}catch(Y){throw this.error("QevoWindows","Error getting window:",Y),Y}}async getCurrent(J){try{if(B)return await _.windows.getCurrent(J);else return await _.windows.getCurrent(J)}catch(X){throw this.error("QevoWindows","Error getting current window:",X),X}}async getLastFocused(J){try{if(B)return await _.windows.getLastFocused(J);else return await _.windows.getLastFocused(J)}catch(X){throw this.error("QevoWindows","Error getting last focused window:",X),X}}async getAll(J){try{if(B)return await _.windows.getAll(J);else return await _.windows.getAll(J)}catch(X){return this.error("QevoWindows","Error getting all windows:",X),[]}}async update(J,X){try{if(B)return await _.windows.update(J,X);else return await _.windows.update(J,X)}catch(Y){throw this.error("QevoWindows","Error updating window:",Y),Y}}async remove(J){try{if(B)await _.windows.remove(J);else await _.windows.remove(J)}catch(X){throw this.error("QevoWindows","Error removing window:",X),X}}get WINDOW_ID_NONE(){if(B)return _.windows.WINDOW_ID_NONE;else return _.windows.WINDOW_ID_NONE}get WINDOW_ID_CURRENT(){if(B)return _.windows.WINDOW_ID_CURRENT;else return _.windows.WINDOW_ID_CURRENT}onFocusChanged(J){this.focusChangedListeners.add(J),this.ensureListenersInitialized()}offFocusChanged(J){this.focusChangedListeners.delete(J)}onCreated(J){this.createdListeners.add(J),this.ensureListenersInitialized()}offCreated(J){this.createdListeners.delete(J)}onRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offRemoved(J){this.removedListeners.delete(J)}isAvailable(){try{return!!_.windows}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;let J=(G)=>{this.focusChangedListeners.forEach(($)=>{try{$(G)}catch(U){this.error("QevoWindows","Error in focus listener:",U)}})},X=(G)=>{this.createdListeners.forEach(($)=>{try{$(G)}catch(U){this.error("QevoWindows","Error in created listener:",U)}})},Y=(G)=>{this.removedListeners.forEach(($)=>{try{$(G)}catch(U){this.error("QevoWindows","Error in removed listener:",U)}})};if(B){let G=_;G.windows.onFocusChanged.addListener(J),G.windows.onCreated.addListener(X),G.windows.onRemoved.addListener(Y)}else{let G=_;G.windows.onFocusChanged.addListener(J),G.windows.onCreated.addListener(X),G.windows.onRemoved.addListener(Y)}this.listenersInitialized=!0}}class f extends E{addedListeners=new Set;removedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async contains(J){try{if(B)return await _.permissions.contains(J);else return await _.permissions.contains(J)}catch(X){return this.error("QevoPermissions","Error checking permissions:",X),!1}}async getAll(){try{if(B)return await _.permissions.getAll();else return await _.permissions.getAll()}catch(J){return this.error("QevoPermissions","Error getting all permissions:",J),{}}}async request(J){try{if(B)return await _.permissions.request(J);else return await _.permissions.request(J)}catch(X){return this.error("QevoPermissions","Error requesting permissions:",X),!1}}async remove(J){try{if(B)return await _.permissions.remove(J);else return await _.permissions.remove(J)}catch(X){return this.error("QevoPermissions","Error removing permissions:",X),!1}}onAdded(J){this.addedListeners.add(J),this.ensureListenersInitialized()}offAdded(J){this.addedListeners.delete(J)}onRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offRemoved(J){this.removedListeners.delete(J)}isAvailable(){try{return!!_.permissions}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;let J=(Y)=>{this.addedListeners.forEach((G)=>{try{G(Y)}catch($){this.error("QevoPermissions","Error in added listener:",$)}})},X=(Y)=>{this.removedListeners.forEach((G)=>{try{G(Y)}catch($){this.error("QevoPermissions","Error in removed listener:",$)}})};if(B){let Y=_;Y.permissions.onAdded.addListener(J),Y.permissions.onRemoved.addListener(X)}else{let Y=_;Y.permissions.onAdded.addListener(J),Y.permissions.onRemoved.addListener(X)}this.listenersInitialized=!0}}class A extends E{createdListeners=new Set;changedListeners=new Set;erasedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async download(J){try{if(B)return await _.downloads.download(J);else return await _.downloads.download(J)}catch(X){throw this.error("QevoDownloads","Error downloading:",X),X}}async search(J){try{if(B)return await _.downloads.search(J);else return await _.downloads.search(J)}catch(X){return this.error("QevoDownloads","Error searching downloads:",X),[]}}async pause(J){try{if(B)await _.downloads.pause(J);else await _.downloads.pause(J)}catch(X){throw this.error("QevoDownloads","Error pausing download:",X),X}}async resume(J){try{if(B)await _.downloads.resume(J);else await _.downloads.resume(J)}catch(X){throw this.error("QevoDownloads","Error resuming download:",X),X}}async cancel(J){try{if(B)await _.downloads.cancel(J);else await _.downloads.cancel(J)}catch(X){throw this.error("QevoDownloads","Error canceling download:",X),X}}async erase(J){try{if(B)return await _.downloads.erase(J);else return await _.downloads.erase(J)}catch(X){return this.error("QevoDownloads","Error erasing downloads:",X),[]}}async removeFile(J){try{if(B)await _.downloads.removeFile(J);else await _.downloads.removeFile(J)}catch(X){throw this.error("QevoDownloads","Error removing file:",X),X}}async open(J){try{if(B)await _.downloads.open(J);else await _.downloads.open(J)}catch(X){throw this.error("QevoDownloads","Error opening file:",X),X}}async show(J){try{if(B)await _.downloads.show(J);else await _.downloads.show(J)}catch(X){throw this.error("QevoDownloads","Error showing file:",X),X}}async showDefaultFolder(){try{if(B)await _.downloads.showDefaultFolder();else await _.downloads.showDefaultFolder()}catch(J){throw this.error("QevoDownloads","Error showing default folder:",J),J}}async getFileIcon(J,X){try{if(B)if(X!==void 0)return await _.downloads.getFileIcon(J,X);else return await _.downloads.getFileIcon(J);else if(X!==void 0)return await _.downloads.getFileIcon(J,X);else return await _.downloads.getFileIcon(J)}catch(Y){throw this.error("QevoDownloads","Error getting file icon:",Y),Y}}onCreated(J){this.createdListeners.add(J),this.ensureListenersInitialized()}offCreated(J){this.createdListeners.delete(J)}onChanged(J){this.changedListeners.add(J),this.ensureListenersInitialized()}offChanged(J){this.changedListeners.delete(J)}onErased(J){this.erasedListeners.add(J),this.ensureListenersInitialized()}offErased(J){this.erasedListeners.delete(J)}isAvailable(){try{return!!_.downloads}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if(B){let J=_;J.downloads.onCreated.addListener((X)=>{this.createdListeners.forEach((Y)=>Y(X))}),J.downloads.onChanged.addListener((X)=>{this.changedListeners.forEach((Y)=>Y(X))}),J.downloads.onErased.addListener((X)=>{this.erasedListeners.forEach((Y)=>Y(X))})}else{let J=_;J.downloads.onCreated.addListener((X)=>{this.createdListeners.forEach((Y)=>Y(X))}),J.downloads.onChanged.addListener((X)=>{this.changedListeners.forEach((Y)=>Y(X))}),J.downloads.onErased.addListener((X)=>{this.erasedListeners.forEach((Y)=>Y(X))})}this.listenersInitialized=!0}}class m extends E{visitedListeners=new Set;removedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async search(J){try{if(B)return await _.history.search(J);else return await _.history.search(J)}catch(X){return this.error("QevoHistory","Error searching history:",X),[]}}async getVisits(J){try{if(B)return await _.history.getVisits(J);else return await _.history.getVisits(J)}catch(X){return this.error("QevoHistory","Error getting visits:",X),[]}}async addUrl(J){try{if(B)await _.history.addUrl(J);else await _.history.addUrl(J)}catch(X){throw this.error("QevoHistory","Error adding URL:",X),X}}async deleteUrl(J){try{if(B)await _.history.deleteUrl(J);else await _.history.deleteUrl(J)}catch(X){throw this.error("QevoHistory","Error deleting URL:",X),X}}async deleteRange(J){try{if(B)await _.history.deleteRange(J);else await _.history.deleteRange(J)}catch(X){throw this.error("QevoHistory","Error deleting range:",X),X}}async deleteAll(){try{if(B)await _.history.deleteAll();else await _.history.deleteAll()}catch(J){throw this.error("QevoHistory","Error deleting all history:",J),J}}onVisited(J){this.visitedListeners.add(J),this.ensureListenersInitialized()}offVisited(J){this.visitedListeners.delete(J)}onVisitRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offVisitRemoved(J){this.removedListeners.delete(J)}isAvailable(){try{return!!_.history}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if(B){let J=_;J.history.onVisited.addListener((X)=>{this.visitedListeners.forEach((Y)=>Y(X))}),J.history.onVisitRemoved.addListener((X)=>{this.removedListeners.forEach((Y)=>Y(X))})}else{let J=_;J.history.onVisited.addListener((X)=>{this.visitedListeners.forEach((Y)=>Y(X))}),J.history.onVisitRemoved.addListener((X)=>{this.removedListeners.forEach((Y)=>Y(X))})}this.listenersInitialized=!0}}class P extends E{createdListeners=new Set;removedListeners=new Set;changedListeners=new Set;movedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async getTree(){try{if(B)return await _.bookmarks.getTree();else return await _.bookmarks.getTree()}catch(J){return this.error("QevoBookmarks","Error getting tree:",J),[]}}async getSubTree(J){try{if(B)return await _.bookmarks.getSubTree(J);else return await _.bookmarks.getSubTree(J)}catch(X){return this.error("QevoBookmarks","Error getting subtree:",X),[]}}async get(J){try{if(B)return await _.bookmarks.get(J);else return await _.bookmarks.get(J)}catch(X){return this.error("QevoBookmarks","Error getting bookmarks:",X),[]}}async getChildren(J){try{if(B)return await _.bookmarks.getChildren(J);else return await _.bookmarks.getChildren(J)}catch(X){return this.error("QevoBookmarks","Error getting children:",X),[]}}async getRecent(J){try{if(B)return await _.bookmarks.getRecent(J);else return await _.bookmarks.getRecent(J)}catch(X){return this.error("QevoBookmarks","Error getting recent:",X),[]}}async search(J){try{if(B)return await _.bookmarks.search(J);else return await _.bookmarks.search(J)}catch(X){return this.error("QevoBookmarks","Error searching:",X),[]}}async create(J){try{if(B)return await _.bookmarks.create(J);else return await _.bookmarks.create(J)}catch(X){throw this.error("QevoBookmarks","Error creating bookmark:",X),X}}async update(J,X){try{if(B)return await _.bookmarks.update(J,X);else return await _.bookmarks.update(J,X)}catch(Y){throw this.error("QevoBookmarks","Error updating bookmark:",Y),Y}}async move(J,X){try{if(B)return await _.bookmarks.move(J,X);else return await _.bookmarks.move(J,X)}catch(Y){throw this.error("QevoBookmarks","Error moving bookmark:",Y),Y}}async remove(J){try{if(B)await _.bookmarks.remove(J);else await _.bookmarks.remove(J)}catch(X){throw this.error("QevoBookmarks","Error removing bookmark:",X),X}}async removeTree(J){try{if(B)await _.bookmarks.removeTree(J);else await _.bookmarks.removeTree(J)}catch(X){throw this.error("QevoBookmarks","Error removing tree:",X),X}}onCreated(J){this.createdListeners.add(J),this.ensureListenersInitialized()}offCreated(J){this.createdListeners.delete(J)}onRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offRemoved(J){this.removedListeners.delete(J)}onChanged(J){this.changedListeners.add(J),this.ensureListenersInitialized()}offChanged(J){this.changedListeners.delete(J)}onMoved(J){this.movedListeners.add(J),this.ensureListenersInitialized()}offMoved(J){this.movedListeners.delete(J)}isAvailable(){try{return!!_.bookmarks}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if(B){let J=_;J.bookmarks.onCreated.addListener((X,Y)=>{this.createdListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onRemoved.addListener((X,Y)=>{this.removedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onChanged.addListener((X,Y)=>{this.changedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onMoved.addListener((X,Y)=>{this.movedListeners.forEach((G)=>G(X,Y))})}else{let J=_;J.bookmarks.onCreated.addListener((X,Y)=>{this.createdListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onRemoved.addListener((X,Y)=>{this.removedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onChanged.addListener((X,Y)=>{this.changedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onMoved.addListener((X,Y)=>{this.movedListeners.forEach((G)=>G(X,Y))})}this.listenersInitialized=!0}}class c extends E{constructor(J=!1){super(J)}async getAuthToken(J={}){try{if(B){this.warn("QevoIdentity","getAuthToken not available in Firefox, use launchWebAuthFlow");return}else{let X=await _.identity.getAuthToken(J);return typeof X==="string"?X:X?.token}}catch(X){throw this.error("QevoIdentity","Error getting auth token:",X),X}}async removeCachedAuthToken(J){try{if(B)this.warn("QevoIdentity","removeCachedAuthToken not available in Firefox");else await _.identity.removeCachedAuthToken(J)}catch(X){throw this.error("QevoIdentity","Error removing cached token:",X),X}}async clearAllCachedAuthTokens(){try{if(B)this.warn("QevoIdentity","clearAllCachedAuthTokens not available in Firefox");else if(typeof _.identity.clearAllCachedAuthTokens==="function")await _.identity.clearAllCachedAuthTokens()}catch(J){throw this.error("QevoIdentity","Error clearing cached tokens:",J),J}}async launchWebAuthFlow(J){try{if(B)return await _.identity.launchWebAuthFlow(J);else return await _.identity.launchWebAuthFlow(J)||""}catch(X){throw this.error("QevoIdentity","Error launching web auth flow:",X),X}}getRedirectURL(J){try{if(B)return _.identity.getRedirectURL(J);else return _.identity.getRedirectURL(J)}catch(X){throw this.error("QevoIdentity","Error getting redirect URL:",X),X}}async getProfileUserInfo(){try{if(B){this.warn("QevoIdentity","getProfileUserInfo not available in Firefox");return}else return await _.identity.getProfileUserInfo({})}catch(J){this.error("QevoIdentity","Error getting profile info:",J);return}}async getAccounts(){try{if(B)return[];else if(typeof _.identity.getAccounts==="function")return await _.identity.getAccounts();return[]}catch(J){return this.error("QevoIdentity","Error getting accounts:",J),[]}}isAvailable(){try{return!!_.identity}catch{return!1}}}class w extends E{commandListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}async getAll(){try{if(B)return await _.commands.getAll();else return await _.commands.getAll()}catch(J){return this.error("QevoCommands","Error getting commands:",J),[]}}onCommand(J){if(this.commandListeners.add(J),!this.listenerInitialized)this.initializeListener()}offCommand(J){this.commandListeners.delete(J)}isAvailable(){try{return!!_.commands}catch{return!1}}initializeListener(){if(this.listenerInitialized)return;let J=(X,Y)=>{this.commandListeners.forEach((G)=>{try{G(X,Y)}catch($){this.error("QevoCommands","Error in command listener:",$)}})};if(B)_.commands.onCommand.addListener(J);else _.commands.onCommand.addListener(J);this.listenerInitialized=!0}}class p extends E{constructor(J=!1){super(J)}getMessage(J,X){try{if(B)return _.i18n.getMessage(J,X);else return _.i18n.getMessage(J,X)}catch(Y){return this.error("QevoI18n","Error getting message:",Y),""}}getUILanguage(){try{if(B)return _.i18n.getUILanguage();else return _.i18n.getUILanguage()}catch(J){return this.error("QevoI18n","Error getting UI language:",J),"en"}}async getAcceptLanguages(){try{if(B)return await _.i18n.getAcceptLanguages();else return await _.i18n.getAcceptLanguages()}catch(J){return this.error("QevoI18n","Error getting accept languages:",J),[]}}async detectLanguage(J){try{if(B)return await _.i18n.detectLanguage(J);else return await _.i18n.detectLanguage(J)}catch(X){return this.error("QevoI18n","Error detecting language:",X),{isReliable:!1,languages:[]}}}isAvailable(){try{return!!_.i18n}catch{return!1}}}class b extends E{stateChangedListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}async queryState(J){try{if(B)return await _.idle.queryState(J);else return await _.idle.queryState(J)}catch(X){return this.error("QevoIdle","Error querying state:",X),"active"}}setDetectionInterval(J){try{if(B)_.idle.setDetectionInterval(J);else _.idle.setDetectionInterval(J)}catch(X){this.error("QevoIdle","Error setting detection interval:",X)}}async getAutoLockDelay(){try{if(B)return 0;else if(typeof _.idle.getAutoLockDelay==="function")return await _.idle.getAutoLockDelay();return 0}catch(J){return this.error("QevoIdle","Error getting auto-lock delay:",J),0}}onStateChanged(J){if(this.stateChangedListeners.add(J),!this.listenerInitialized)this.initializeListener()}offStateChanged(J){this.stateChangedListeners.delete(J)}isAvailable(){try{return!!_.idle}catch{return!1}}initializeListener(){if(this.listenerInitialized)return;let J=(X)=>{this.stateChangedListeners.forEach((Y)=>{try{Y(X)}catch(G){this.error("QevoIdle","Error in state change listener:",G)}})};if(B)_.idle.onStateChanged.addListener(J);else _.idle.onStateChanged.addListener(J);this.listenerInitialized=!0}}class d extends E{installedListeners=new Set;startupListeners=new Set;suspendListeners=new Set;connectListeners=new Set;updateAvailableListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}get id(){return _.runtime.id}getManifest(){return _.runtime.getManifest()}getURL(J){return _.runtime.getURL(J)}async getPlatformInfo(){try{if(B)return await _.runtime.getPlatformInfo();else return await _.runtime.getPlatformInfo()}catch(J){throw this.error("QevoRuntime","Error getting platform info:",J),J}}async openOptionsPage(){try{if(B)await _.runtime.openOptionsPage();else await _.runtime.openOptionsPage()}catch(J){throw this.error("QevoRuntime","Error opening options page:",J),J}}reload(){_.runtime.reload()}async requestUpdateCheck(){try{if(B)return{status:"no_update"};else return await _.runtime.requestUpdateCheck()}catch(J){return this.error("QevoRuntime","Error requesting update check:",J),{status:"error"}}}async setUninstallURL(J){try{if(B)await _.runtime.setUninstallURL(J);else await _.runtime.setUninstallURL(J)}catch(X){throw this.error("QevoRuntime","Error setting uninstall URL:",X),X}}connect(J,X){if(B){if(typeof J==="string")return _.runtime.connect(J,X);return _.runtime.connect(J||{})}else{if(typeof J==="string")return _.runtime.connect(J,X);return _.runtime.connect(J||{})}}connectNative(J){if(B)return _.runtime.connectNative(J);else return _.runtime.connectNative(J)}get lastError(){return _.runtime.lastError}onInstalled(J){this.installedListeners.add(J),this.ensureListenersInitialized()}offInstalled(J){this.installedListeners.delete(J)}onStartup(J){this.startupListeners.add(J),this.ensureListenersInitialized()}offStartup(J){this.startupListeners.delete(J)}onSuspend(J){this.suspendListeners.add(J),this.ensureListenersInitialized()}offSuspend(J){this.suspendListeners.delete(J)}onConnect(J){this.connectListeners.add(J),this.ensureListenersInitialized()}offConnect(J){this.connectListeners.delete(J)}onUpdateAvailable(J){this.updateAvailableListeners.add(J),this.ensureListenersInitialized()}offUpdateAvailable(J){this.updateAvailableListeners.delete(J)}isAvailable(){try{return!!_.runtime}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if(B){let J=_;if(J.runtime.onInstalled.addListener((X)=>{this.installedListeners.forEach((Y)=>Y(X))}),J.runtime.onStartup.addListener(()=>{this.startupListeners.forEach((X)=>X())}),J.runtime.onSuspend)J.runtime.onSuspend.addListener(()=>{this.suspendListeners.forEach((X)=>X())});if(J.runtime.onConnect.addListener((X)=>{this.connectListeners.forEach((Y)=>Y(X))}),J.runtime.onUpdateAvailable)J.runtime.onUpdateAvailable.addListener((X)=>{this.updateAvailableListeners.forEach((Y)=>Y(X))})}else{let J=_;if(J.runtime.onInstalled.addListener((X)=>{this.installedListeners.forEach((Y)=>Y(X))}),J.runtime.onStartup.addListener(()=>{this.startupListeners.forEach((X)=>X())}),J.runtime.onSuspend)J.runtime.onSuspend.addListener(()=>{this.suspendListeners.forEach((X)=>X())});J.runtime.onConnect.addListener((X)=>{this.connectListeners.forEach((Y)=>Y(X))}),J.runtime.onUpdateAvailable.addListener((X)=>{this.updateAvailableListeners.forEach((Y)=>Y(X))})}this.listenersInitialized=!0}}class R{static instance;_debug;_tabsInstance;_cookiesInstance;_messagesInstance;_webRequestInstance;_alarmsInstance;_notificationsInstance;_contextMenusInstance;_scriptingInstance;_actionInstance;_windowsInstance;_permissionsInstance;_downloadsInstance;_historyInstance;_bookmarksInstance;_identityInstance;_commandsInstance;_i18nInstance;_idleInstance;_runtimeInstance;constructor(){this._debug=T(),this.log("\uD83D\uDE80 Qevo initialized")}set debug(J){if(this._debug=J,this._tabsInstance)this._tabsInstance.debug=J;if(this._cookiesInstance)this._cookiesInstance.debug=J;if(this._messagesInstance)this._messagesInstance.debug=J;if(this._webRequestInstance)this._webRequestInstance.debug=J;if(this._alarmsInstance)this._alarmsInstance.debug=J;if(this._notificationsInstance)this._notificationsInstance.debug=J;if(this._contextMenusInstance)this._contextMenusInstance.debug=J;if(this._scriptingInstance)this._scriptingInstance.debug=J;if(this._actionInstance)this._actionInstance.debug=J;if(this._windowsInstance)this._windowsInstance.debug=J;if(this._permissionsInstance)this._permissionsInstance.debug=J;if(this._downloadsInstance)this._downloadsInstance.debug=J;if(this._historyInstance)this._historyInstance.debug=J;if(this._bookmarksInstance)this._bookmarksInstance.debug=J;if(this._identityInstance)this._identityInstance.debug=J;if(this._commandsInstance)this._commandsInstance.debug=J;if(this._i18nInstance)this._i18nInstance.debug=J;if(this._idleInstance)this._idleInstance.debug=J;if(this._runtimeInstance)this._runtimeInstance.debug=J;this.log(`\uD83D\uDD27 Debug mode: ${J?"ENABLED":"DISABLED"}`)}get debug(){return this._debug}get tabs(){if(!this._tabsInstance)this._tabsInstance=new h(this._debug);return this._tabsInstance}get cookies(){if(!this._cookiesInstance)this._cookiesInstance=new O(this._debug);return this._cookiesInstance}get messages(){if(!this._messagesInstance)this._messagesInstance=new q(this._debug);return this._messagesInstance}get webRequest(){if(!this._webRequestInstance)this._webRequestInstance=new F(this._debug);return this._webRequestInstance}get storage(){return a}get alarms(){if(!this._alarmsInstance)this._alarmsInstance=new x(this._debug);return this._alarmsInstance}get notifications(){if(!this._notificationsInstance)this._notificationsInstance=new g(this._debug);return this._notificationsInstance}get contextMenus(){if(!this._contextMenusInstance)this._contextMenusInstance=new k(this._debug);return this._contextMenusInstance}get scripting(){if(!this._scriptingInstance)this._scriptingInstance=new y(this._debug);return this._scriptingInstance}get action(){if(!this._actionInstance)this._actionInstance=new v(this._debug);return this._actionInstance}get windows(){if(!this._windowsInstance)this._windowsInstance=new u(this._debug);return this._windowsInstance}get permissions(){if(!this._permissionsInstance)this._permissionsInstance=new f(this._debug);return this._permissionsInstance}get downloads(){if(!this._downloadsInstance)this._downloadsInstance=new A(this._debug);return this._downloadsInstance}get history(){if(!this._historyInstance)this._historyInstance=new m(this._debug);return this._historyInstance}get bookmarks(){if(!this._bookmarksInstance)this._bookmarksInstance=new P(this._debug);return this._bookmarksInstance}get identity(){if(!this._identityInstance)this._identityInstance=new c(this._debug);return this._identityInstance}get commands(){if(!this._commandsInstance)this._commandsInstance=new w(this._debug);return this._commandsInstance}get i18n(){if(!this._i18nInstance)this._i18nInstance=new p(this._debug);return this._i18nInstance}get idle(){if(!this._idleInstance)this._idleInstance=new b(this._debug);return this._idleInstance}get runtime(){if(!this._runtimeInstance)this._runtimeInstance=new d(this._debug);return this._runtimeInstance}isBackgroundScript(){try{return!!_.runtime?.getManifest()?.background}catch{return!1}}isContentScript(){return typeof window<"u"&&window.location!==void 0}getBrowserType(){if(typeof browser<"u"&&browser.runtime)return"firefox";if(typeof chrome<"u")return"chrome";return"unknown"}log(...J){if(this._debug)console.log("[Qevo]",...J)}static getInstance(){if(!R.instance)R.instance=new R;return R.instance}}var L=R.getInstance(),gX=L,BX=L.isBackgroundScript.bind(L),MX=L.isContentScript.bind(L),UX=L.getBrowserType.bind(L),WX=L.storage,EX=L.cookies,ZX=L.tabs,HX=L.webRequest,LX=L.messages,DX=L.alarms,zX=L.notifications,KX=L.contextMenus,CX=L.scripting,RX=L.action,NX=L.windows,QX=L.permissions,VX=L.downloads,SX=L.history,jX=L.bookmarks,hX=L.identity,TX=L.commands,OX=L.i18n,qX=L.idle,FX=L.runtime;export{NX as windows,HX as webRequest,ZX as tabs,WX as storage,CX as scripting,FX as runtime,L as qevo,QX as permissions,zX as notifications,LX as messages,MX as isContentScript,BX as isBackgroundScript,qX as idle,hX as identity,OX as i18n,SX as history,UX as getBrowserType,VX as downloads,gX as default,EX as cookies,KX as contextMenus,TX as commands,jX as bookmarks,DX as alarms,RX as action,R as Qevo};
