class O{debug=!1;listeners={add:new Set,update:new Set,remove:new Set};cleanupIntervalId;CLEANUP_INTERVAL_MS=30000;constructor(){this.initializeCleanup()}addListener(J,X){this.listeners[J].add(X)}removeListener(J,X){this.listeners[J].delete(X)}triggerListeners(J,X,Y,G){try{switch(J){case"add":this.listeners.add.forEach((W)=>W(X,G));break;case"remove":this.listeners.remove.forEach((W)=>W(X));break;case"update":this.listeners.update.forEach((W)=>W(X,Y,G));break}}catch(W){if(this.debug)throw console.error(`Error in storage change handler for key ${X}:`,W),W}}initializeCleanup(){if(this.shouldRunCleanup())this.startCleanup()}shouldRunCleanup(){return!0}isServiceWorker(){return typeof self<"u"&&"ServiceWorkerGlobalScope"in self&&self instanceof self.ServiceWorkerGlobalScope}startCleanup(){if(this.cleanupIntervalId)clearInterval(this.cleanupIntervalId);this.cleanupIntervalId=setInterval(()=>{this.cleanupExpired().catch((J)=>{if(this.debug)throw console.error("Cleanup interval error:",J),J})},this.CLEANUP_INTERVAL_MS)}stopCleanup(){if(this.cleanupIntervalId)clearInterval(this.cleanupIntervalId),this.cleanupIntervalId=void 0}destroy(){this.stopCleanup(),this.listeners.add.clear(),this.listeners.update.clear(),this.listeners.remove.clear()}}class WJ extends O{STORAGE_QUOTA_BYTES=8388608;boundStorageHandler=null;constructor(){super();if(this.isContextValid()&&chrome?.storage?.onChanged)this.boundStorageHandler=this.handleStorageChange.bind(this),chrome.storage.onChanged.addListener(this.boundStorageHandler)}isContextValid(){try{return!!chrome.runtime?.id}catch{return!1}}shouldRunCleanup(){return this.isBackgroundScript()&&!this.isServiceWorker()}async put(J,X,Y){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot set key ${J}: Extension context invalidated`);return}try{let{ttl:G,expires:W}=Y||{},Z=G?Date.now()+G*1000:W?W.getTime():void 0,U={value:X,expires:Z};await chrome.storage.local.set({[J]:U})}catch(G){if(G.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot set key ${J}: Extension context invalidated`)}else{if(this.debug)console.error(`Failed to set key ${J}:`,G);throw Error(`Storage set operation failed for key ${J}`)}}}async get(J,X){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get key ${J}: Extension context invalidated`);return null}try{if(X){let W=await this.listKeys(J);if(W.length===0)return null;J=W[0]}let G=(await chrome.storage.local.get(J))[J];if(!G)return null;if(G.expires&&Date.now()>G.expires)return await this.remove(J),null;return G.value}catch(Y){if(Y.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot get key ${J}: Extension context invalidated`);return null}if(this.debug)console.error(`Failed to get key ${J}:`,Y);return null}}async getWithMetadata(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get metadata for key ${J}: Extension context invalidated`);return null}try{let Y=(await chrome.storage.local.get(J))[J];if(!Y)return null;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),null;return Y}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot get metadata for key ${J}: Extension context invalidated`);return null}if(this.debug)console.error(`Failed to get metadata for key ${J}:`,X);return null}}async has(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot check key ${J}: Extension context invalidated`);return!1}try{let Y=(await chrome.storage.local.get(J))[J];if(!Y)return!1;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),!1;return!0}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot check key ${J}: Extension context invalidated`);return!1}if(this.debug)console.error(`Failed to check key ${J}:`,X);return!1}}async remove(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot remove key ${J}: Extension context invalidated`);return}try{await chrome.storage.local.remove(J)}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn(`Cannot remove key ${J}: Extension context invalidated`)}else if(this.debug)console.error(`Failed to remove key ${J}:`,X)}}async length(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage length: Extension context invalidated");return 0}try{let J=await chrome.storage.local.get(null);return Object.keys(J).length}catch(J){if(J.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot get storage length: Extension context invalidated");return 0}if(this.debug)console.error("Failed to get storage length:",J);return 0}}async listKeys(J=""){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return[]}try{let X=await chrome.storage.local.get(null);return Object.keys(X).filter((Y)=>J.length>0?Y.startsWith(J):!0)}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return[]}if(this.debug)console.error("Failed to list keys:",X);return[]}}async getKeyByPrefix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await chrome.storage.local.get(null);return Object.keys(X).find((Y)=>Y.startsWith(J))}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}if(this.debug)console.error("Failed to list keys:",X);return}}async getKeyBySuffix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await chrome.storage.local.get(null);return Object.keys(X).find((Y)=>Y.endsWith(J))}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}if(this.debug)console.error("Failed to list keys:",X);return}}async batch(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch operations: Extension context invalidated");return J.map(()=>{return})}try{let X=[],Y={},G=[];for(let W of J)switch(W.type){case"set":if(W.value!==void 0){let U=W.ttl?Date.now()+W.ttl*1000:W.expires?W.expires.getTime():void 0;Y[W.key]={value:W.value,expires:U}}X.push(void 0);break;case"remove":G.push(W.key),X.push(void 0);break;case"get":let Z=await this.get(W.key);X.push(Z);break}if(Object.keys(Y).length>0){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch set: Extension context invalidated");return J.map(()=>{return})}await chrome.storage.local.set(Y)}if(G.length>0){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch remove: Extension context invalidated");return J.map(()=>{return})}try{await chrome.storage.local.remove(G)}catch(W){if(W.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot perform batch remove: Extension context invalidated");return J.map(()=>{return})}throw W}}return X}catch(X){if(X.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot perform batch operations: Extension context invalidated");return J.map(()=>{return})}if(this.debug)console.error("Batch operation failed:",X);if(this.debug)throw Error("Batch operation failed");else return J.map(()=>{return})}}async getStorageUsage(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage usage: Extension context invalidated");return 0}try{return await chrome.storage.local.getBytesInUse()}catch(J){if(J.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot get storage usage: Extension context invalidated");return 0}if(this.debug)console.error("Failed to get storage usage:",J);return 0}}async cleanupExpired(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");this.stopCleanup();return}try{let J=await chrome.storage.local.get(null),X=Date.now(),Y=[];for(let G in J){let W=J[G];if(W?.expires&&X>W.expires)Y.push(G)}if(Y.length>0){if(!this.isContextValid()){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");return}await chrome.storage.local.remove(Y)}}catch(J){if(J.message?.includes("context invalidated")){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");this.stopCleanup()}else if(this.debug)throw console.error("Failed to clean up expired keys:",J),J}}handleStorageChange(J,X){if(X!=="local"||!this.isContextValid())return;for(let[Y,{oldValue:G,newValue:W}]of Object.entries(J))if(G===void 0&&W!==void 0)this.triggerListeners("add",Y,void 0,W?.value||W);else if(W===void 0&&G!==void 0)this.triggerListeners("remove",Y);else if(G!==void 0&&W!==void 0)this.triggerListeners("update",Y,G?.value||G,W?.value||W)}isBackgroundScript(){try{return!!chrome.runtime?.getManifest()?.background}catch{return!1}}destroy(){if(this.boundStorageHandler&&chrome?.storage?.onChanged){try{chrome.storage.onChanged.removeListener(this.boundStorageHandler)}catch(J){if(this.debug)console.error("Failed to remove storage listener:",J)}this.boundStorageHandler=null}super.destroy()}}class BJ extends O{boundStorageHandler=null;constructor(){super();if(this.isContextValid()&&browser?.storage?.onChanged)this.boundStorageHandler=this.handleStorageChange.bind(this),browser.storage.onChanged.addListener(this.boundStorageHandler)}isContextValid(){try{return typeof browser<"u"&&!!browser.runtime?.id}catch{return!1}}shouldRunCleanup(){return this.isBackgroundScript()&&!this.isServiceWorker()}async put(J,X,Y){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot set key ${J}: Extension context invalidated`);return}try{let{ttl:G,expires:W}=Y||{},Z=G?Date.now()+G*1000:W?W.getTime():void 0,U={value:X,expires:Z};await browser.storage.local.set({[J]:U})}catch(G){if(this.debug)console.error(`Failed to set key ${J}:`,G);if(this.debug)throw Error(`Storage set operation failed for key ${J}`)}}async get(J,X){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get key ${J}: Extension context invalidated`);return null}try{if(X){let W=await this.listKeys(J);if(W.length===0)return null;J=W[0]}let G=(await browser.storage.local.get(J))[J];if(!G)return null;if(G.expires&&Date.now()>G.expires)return await this.remove(J),null;return G.value}catch(Y){if(this.debug)console.error(`Failed to get key ${J}:`,Y);return null}}async getWithMetadata(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot get metadata for key ${J}: Extension context invalidated`);return null}try{let Y=(await browser.storage.local.get(J))[J];if(!Y)return null;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),null;return Y}catch(X){if(this.debug)console.error(`Failed to get metadata for key ${J}:`,X);return null}}async has(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot check key ${J}: Extension context invalidated`);return!1}try{let Y=(await browser.storage.local.get(J))[J];if(!Y)return!1;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),!1;return!0}catch(X){if(this.debug)console.error(`Failed to check key ${J}:`,X);return!1}}async remove(J){if(!this.isContextValid()){if(this.debug)console.warn(`Cannot remove key ${J}: Extension context invalidated`);return}try{await browser.storage.local.remove(J)}catch(X){if(this.debug)console.error(`Failed to remove key ${J}:`,X)}}async length(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage length: Extension context invalidated");return 0}try{let J=await browser.storage.local.get(null);return Object.keys(J).length}catch(J){if(this.debug)console.error("Failed to get storage length:",J);return 0}}async listKeys(J=""){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return[]}try{let X=await browser.storage.local.get(null);return Object.keys(X).filter((Y)=>J.length>0?Y.startsWith(J):!0)}catch(X){if(this.debug)console.error("Failed to list keys:",X);return[]}}async getKeyByPrefix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await browser.storage.local.get(null);return Object.keys(X).find((Y)=>Y.startsWith(J))}catch(X){if(this.debug)console.error("Failed to list keys:",X);return}}async getKeyBySuffix(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot list keys: Extension context invalidated");return}try{let X=await browser.storage.local.get(null);return Object.keys(X).find((Y)=>Y.endsWith(J))}catch(X){if(this.debug)console.error("Failed to list keys:",X);return}}async batch(J){if(!this.isContextValid()){if(this.debug)console.warn("Cannot perform batch operations: Extension context invalidated");return J.map(()=>{return})}let X=[];try{let Y={},G=[];for(let W of J)switch(W.type){case"set":if(W.value!==void 0){let U=W.ttl?Date.now()+W.ttl*1000:W.expires?W.expires.getTime():void 0;Y[W.key]={value:W.value,expires:U}}X.push(void 0);break;case"remove":G.push(W.key),X.push(void 0);break;case"get":let Z=await this.get(W.key);X.push(Z);break}if(Object.keys(Y).length>0)await browser.storage.local.set(Y);if(G.length>0)await browser.storage.local.remove(G);return X}catch(Y){if(this.debug)console.error("Batch operation failed:",Y);if(this.debug)throw Error("Batch operation failed");return X}}async getStorageUsage(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot get storage usage: Extension context invalidated");return 0}try{let J=await browser.storage.local.get(null),X=JSON.stringify(J);return new Blob([X]).size}catch(J){if(this.debug)console.error("Failed to get storage usage:",J);return 0}}async cleanupExpired(){if(!this.isContextValid()){if(this.debug)console.warn("Cannot clean up expired keys: Extension context invalidated");this.stopCleanup();return}try{let J=await browser.storage.local.get(null),X=Date.now(),Y=[];for(let G in J){let W=J[G];if(W?.expires&&X>W.expires)Y.push(G)}if(Y.length>0)await browser.storage.local.remove(Y)}catch(J){if(this.debug)throw console.error("Failed to clean up expired keys:",J),J}}handleStorageChange(J,X){if(X!=="local"||!this.isContextValid())return;for(let[Y,{oldValue:G,newValue:W}]of Object.entries(J))if(G===void 0&&W!==void 0)this.triggerListeners("add",Y,void 0,W?.value||W);else if(W===void 0&&G!==void 0)this.triggerListeners("remove",Y);else if(G!==void 0&&W!==void 0)this.triggerListeners("update",Y,G?.value||G,W?.value||W)}isBackgroundScript(){try{return!!browser.runtime?.getManifest()?.background}catch{return!1}}destroy(){if(this.boundStorageHandler&&browser?.storage?.onChanged){try{browser.storage.onChanged.removeListener(this.boundStorageHandler)}catch(J){if(this.debug)console.error("Failed to remove storage listener:",J)}this.boundStorageHandler=null}super.destroy()}}class ZJ extends O{dbName="QevoKVStore";dbVersion=1;storeName="keyvalue";db=null;initPromise=null;constructor(){super();this.initPromise=this.initDB()}isContextValid(){return typeof self<"u"&&"indexedDB"in self}shouldRunCleanup(){return!this.isServiceWorker()&&typeof window<"u"}async initDB(){if(!this.isContextValid())throw Error("IndexedDB not available");return new Promise((J,X)=>{let Y=indexedDB.open(this.dbName,this.dbVersion);Y.onerror=()=>X(Y.error),Y.onsuccess=()=>{this.db=Y.result,J()},Y.onupgradeneeded=(G)=>{let W=G.target.result;if(!W.objectStoreNames.contains(this.storeName))W.createObjectStore(this.storeName)}})}async ensureDB(){if(this.initPromise)await this.initPromise;if(!this.db)throw Error("Database not initialized");return this.db}async transaction(J,X){let Y=await this.ensureDB();return new Promise((G,W)=>{let U=Y.transaction([this.storeName],J).objectStore(this.storeName),H=X(U);H.onsuccess=()=>G(H.result),H.onerror=()=>W(H.error)})}async put(J,X,Y){let{ttl:G,expires:W}=Y||{},Z=G?Date.now()+G*1000:W?W.getTime():void 0,U={value:X,expires:Z},H=await this.getWithMetadata(J);if(await this.transaction("readwrite",(D)=>D.put(U,J)),H===null)this.triggerListeners("add",J,void 0,X);else this.triggerListeners("update",J,H.value,X)}async get(J,X){try{if(X){let G=await this.listKeys(J);if(G.length===0)return null;J=G[0]}let Y=await this.transaction("readonly",(G)=>G.get(J));if(!Y)return null;if(Y.expires&&Date.now()>Y.expires)return await this.remove(J),null;return Y.value}catch(Y){if(this.debug)console.error(`Failed to get key ${J}:`,Y);return null}}async getWithMetadata(J){try{let X=await this.transaction("readonly",(Y)=>Y.get(J));if(!X)return null;if(X.expires&&Date.now()>X.expires)return await this.remove(J),null;return X}catch(X){if(this.debug)console.error(`Failed to get metadata for key ${J}:`,X);return null}}async has(J){try{let X=await this.transaction("readonly",(Y)=>Y.get(J));if(!X)return!1;if(X.expires&&Date.now()>X.expires)return await this.remove(J),!1;return!0}catch(X){if(this.debug)console.error(`Failed to check key ${J}:`,X);return!1}}async remove(J){try{await this.transaction("readwrite",(X)=>X.delete(J)),this.triggerListeners("remove",J)}catch(X){if(this.debug)console.error(`Failed to remove key ${J}:`,X)}}async length(){try{return await this.transaction("readonly",(J)=>J.count())}catch(J){if(this.debug)console.error("Failed to get storage length:",J);return 0}}async listKeys(J=""){try{let X=await this.ensureDB();return new Promise((Y,G)=>{let U=X.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();U.onsuccess=()=>{let H=U.result,D=J.length>0?H.filter((C)=>C.startsWith(J)):H;Y(D)},U.onerror=()=>G(U.error)})}catch(X){if(this.debug)console.error("Failed to list keys:",X);return[]}}async getKeyByPrefix(J){let X=await this.listKeys(J);return X.length>0?X[0]:void 0}async getKeyBySuffix(J){return(await this.listKeys()).find((Y)=>Y.endsWith(J))}async batch(J){let X=[];try{for(let Y of J)switch(Y.type){case"set":if(Y.value!==void 0)await this.put(Y.key,Y.value,{ttl:Y.ttl,expires:Y.expires});X.push(void 0);break;case"remove":await this.remove(Y.key),X.push(void 0);break;case"get":let G=await this.get(Y.key);X.push(G);break}return X}catch(Y){if(this.debug)console.error("Batch operation failed:",Y);if(this.debug)throw Error("Batch operation failed");return X}}async getStorageUsage(){try{let J=await this.ensureDB();return new Promise((X,Y)=>{let Z=J.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();Z.onsuccess=()=>{let U=Z.result,H=JSON.stringify(U),D=new Blob([H]).size;X(D)},Z.onerror=()=>Y(Z.error)})}catch(J){if(this.debug)console.error("Failed to get storage usage:",J);return 0}}async cleanupExpired(){try{let J=await this.ensureDB(),X=Date.now(),Y=[];if(await new Promise((G,W)=>{let H=J.transaction([this.storeName],"readonly").objectStore(this.storeName).openCursor();H.onsuccess=(D)=>{let C=D.target.result;if(C){let R=C.value;if(R?.expires&&X>R.expires)Y.push(C.key);C.continue()}else G()},H.onerror=()=>W(H.error)}),Y.length>0){let W=J.transaction([this.storeName],"readwrite").objectStore(this.storeName);for(let Z of Y)W.delete(Z)}}catch(J){if(this.debug)throw console.error("Failed to clean up expired keys:",J),J}}destroy(){if(this.db){try{this.db.close()}catch(J){if(this.debug)console.error("Failed to close IndexedDB connection:",J)}this.db=null}this.initPromise=null,super.destroy()}}function EJ(){if(typeof chrome<"u"&&chrome.runtime&&chrome.storage)return new WJ;if(typeof browser<"u"&&browser.runtime&&browser.storage)return new BJ;if(typeof window<"u"&&"indexedDB"in window)return new ZJ;throw Error("No suitable storage backend available")}var UJ=EJ();var E=typeof browser<"u"&&typeof browser.runtime<"u",B=E?browser:chrome;class T{_debug=!1;constructor(J=!1){this._debug=J}set debug(J){this._debug=J}get debug(){return this._debug}log(...J){if(this._debug)console.log("[QevoTabs]",...J)}error(...J){if(this._debug)console.error("[QevoTabs]",...J)}async create(J){try{if(E)return await B.tabs.create(J);else return await B.tabs.create(J)}catch(X){throw this.error("Error creating tab:",X),X}}async get(J){try{if(E)return await B.tabs.get(J);else return await B.tabs.get(J)}catch(X){throw this.error("Error getting tab:",X),X}}async getCurrent(){try{if(E){let J=await B.tabs.getCurrent();if(!J)throw Error("No current tab found");return J}else{let J=await B.tabs.getCurrent();if(!J)throw Error("No current tab found");return J}}catch(J){throw this.error("Error getting current tab:",J),J}}async query(J){try{if(E)return await B.tabs.query(J);else return await B.tabs.query(J)}catch(X){throw this.error("Error querying tabs:",X),X}}async update(J,X){try{if(typeof J==="number")if(E){let Y=await B.tabs.update(J,X);if(!Y)throw Error("Failed to update tab");return Y}else{let Y=await B.tabs.update(J,X);if(!Y)throw Error("Failed to update tab");return Y}else if(E){let Y=await B.tabs.update(J);if(!Y)throw Error("Failed to update tab");return Y}else{let Y=await B.tabs.update(J);if(!Y)throw Error("Failed to update tab");return Y}}catch(Y){throw this.error("Error updating tab:",Y),Y}}async remove(J){try{if(E)if(Array.isArray(J))await B.tabs.remove(J);else await B.tabs.remove(J);else if(Array.isArray(J))await B.tabs.remove(J);else await B.tabs.remove(J)}catch(X){throw this.error("Error removing tab:",X),X}}async duplicate(J){try{if(E)return await B.tabs.duplicate(J);else return await B.tabs.duplicate(J)}catch(X){throw this.error("Error duplicating tab:",X),X}}async move(J,X){try{if(E)if(Array.isArray(J))return await B.tabs.move(J,X);else return await B.tabs.move(J,X);else if(Array.isArray(J))return await B.tabs.move(J,X);else return await B.tabs.move(J,X)}catch(Y){throw this.error("Error moving tab:",Y),Y}}async reload(J,X){try{if(E)if(J!==void 0)await B.tabs.reload(J,X);else await B.tabs.reload(X);else if(J!==void 0)await B.tabs.reload(J,X);else await B.tabs.reload(X)}catch(Y){throw this.error("Error reloading tab:",Y),Y}}async highlight(J){try{if(E)return await B.tabs.highlight(J);else return await B.tabs.highlight(J)}catch(X){throw this.error("Error highlighting tabs:",X),X}}async discard(J){try{if(E)if(J!==void 0)return await B.tabs.discard(J),await B.tabs.get(J);else throw Error("Firefox requires a tabId for discard()");else if(J!==void 0)return await B.tabs.discard(J);else return await B.tabs.discard()}catch(X){throw this.error("Error discarding tab:",X),X}}async getZoom(J){try{if(E)if(J!==void 0)return await B.tabs.getZoom(J);else return await B.tabs.getZoom();else if(J!==void 0)return await B.tabs.getZoom(J);else return await B.tabs.getZoom()}catch(X){throw this.error("Error getting zoom:",X),X}}async setZoom(J,X){try{if(typeof X==="number")if(E)if(J!==void 0)await B.tabs.setZoom(J,X);else await B.tabs.setZoom(X);else if(J!==void 0)await B.tabs.setZoom(J,X);else await B.tabs.setZoom(X);else if(E)await B.tabs.setZoom(J);else await B.tabs.setZoom(J)}catch(Y){throw this.error("Error setting zoom:",Y),Y}}async getZoomSettings(J){try{if(E)return await B.tabs.getZoomSettings(J);else return await B.tabs.getZoomSettings(J)}catch(X){throw this.error("Error getting zoom settings:",X),X}}async setZoomSettings(J,X){try{if(X)if(E)return await B.tabs.setZoomSettings(J,X);else return await B.tabs.setZoomSettings(J,X);else if(E)return await B.tabs.setZoomSettings(J);else return await B.tabs.setZoomSettings(J)}catch(Y){throw this.error("Error setting zoom settings:",Y),Y}}async getAll(){return this.query({})}async getAllInCurrentWindow(){return this.query({currentWindow:!0})}async getActive(){let[J]=await this.query({active:!0,currentWindow:!0});return J}async findByUrl(J){return(await this.getAll()).find((Y)=>Y.url===J||Y.url?.includes(J))}async findByTitle(J){return(await this.getAll()).find((Y)=>Y.title?.toLowerCase().includes(J.toLowerCase()))}async goBack(J){try{if(E)await B.tabs.goBack(J);else await B.tabs.goBack(J)}catch(X){throw this.error("Error navigating back:",X),X}}async goForward(J){try{if(E)await B.tabs.goForward(J);else await B.tabs.goForward(J)}catch(X){throw this.error("Error navigating forward:",X),X}}async group(J){try{if(E)throw Error("Tab groups are not supported in Firefox");else return await B.tabs.group(J)}catch(X){throw this.error("Error grouping tabs:",X),X}}async ungroup(J){try{if(E)throw Error("Tab groups are not supported in Firefox");else if(Array.isArray(J))await B.tabs.ungroup(J);else await B.tabs.ungroup(J)}catch(X){throw this.error("Error ungrouping tabs:",X),X}}async captureVisibleTab(J,X){try{let Y,G;if(typeof J==="number")Y=J,G=X;else G=J;if(E)if(Y!==void 0)return await B.tabs.captureVisibleTab(Y,G);else return await B.tabs.captureVisibleTab(G);else if(Y!==void 0)return await B.tabs.captureVisibleTab(Y,G);else return await B.tabs.captureVisibleTab(G)}catch(Y){throw this.error("Error capturing visible tab:",Y),Y}}async detectLanguage(J){try{if(E)return await B.tabs.detectLanguage(J);else return await B.tabs.detectLanguage(J)}catch(X){throw this.error("Error detecting language:",X),X}}connect(J,X){try{if(E)return B.tabs.connect(J,X);else return B.tabs.connect(J,X)}catch(Y){throw this.error("Error connecting to tab:",Y),Y}}async sendMessage(J,X,Y){try{if(E)if(Y!==void 0)return await B.tabs.sendMessage(J,X,Y);else return await B.tabs.sendMessage(J,X);else if(Y!==void 0)return await B.tabs.sendMessage(J,X,Y);else return await B.tabs.sendMessage(J,X)}catch(G){throw this.error("Error sending message to tab:",G),G}}async getUrl(J){try{return(await this.get(J)).url}catch(X){this.error("Error getting tab URL:",X);return}}async getTitle(J){try{return(await this.get(J)).title}catch(X){this.error("Error getting tab title:",X);return}}async getFavIcon(J){try{return(await this.get(J)).favIconUrl}catch(X){this.error("Error getting tab favicon:",X);return}}async getWindow(J){try{return(await this.get(J)).windowId}catch(X){throw this.error("Error getting tab window:",X),X}}onActivated={addListener:(J)=>{B.tabs.onActivated.addListener(J)},removeListener:(J)=>{B.tabs.onActivated.removeListener(J)},hasListener:(J)=>{return B.tabs.onActivated.hasListener(J)}};onAttached={addListener:(J)=>{B.tabs.onAttached.addListener(J)},removeListener:(J)=>{B.tabs.onAttached.removeListener(J)},hasListener:(J)=>{return B.tabs.onAttached.hasListener(J)}};onCreated={addListener:(J)=>{B.tabs.onCreated.addListener(J)},removeListener:(J)=>{B.tabs.onCreated.removeListener(J)},hasListener:(J)=>{return B.tabs.onCreated.hasListener(J)}};onDetached={addListener:(J)=>{B.tabs.onDetached.addListener(J)},removeListener:(J)=>{B.tabs.onDetached.removeListener(J)},hasListener:(J)=>{return B.tabs.onDetached.hasListener(J)}};onHighlighted={addListener:(J)=>{B.tabs.onHighlighted.addListener(J)},removeListener:(J)=>{B.tabs.onHighlighted.removeListener(J)},hasListener:(J)=>{return B.tabs.onHighlighted.hasListener(J)}};onMoved={addListener:(J)=>{B.tabs.onMoved.addListener(J)},removeListener:(J)=>{B.tabs.onMoved.removeListener(J)},hasListener:(J)=>{return B.tabs.onMoved.hasListener(J)}};onRemoved={addListener:(J)=>{B.tabs.onRemoved.addListener(J)},removeListener:(J)=>{B.tabs.onRemoved.removeListener(J)},hasListener:(J)=>{return B.tabs.onRemoved.hasListener(J)}};onReplaced={addListener:(J)=>{B.tabs.onReplaced.addListener(J)},removeListener:(J)=>{B.tabs.onReplaced.removeListener(J)},hasListener:(J)=>{return B.tabs.onReplaced.hasListener(J)}};onUpdated={addListener:(J)=>{B.tabs.onUpdated.addListener(J)},removeListener:(J)=>{B.tabs.onUpdated.removeListener(J)},hasListener:(J)=>{return B.tabs.onUpdated.hasListener(J)}};onZoomChange={addListener:(J)=>{B.tabs.onZoomChange.addListener(J)},removeListener:(J)=>{B.tabs.onZoomChange.removeListener(J)},hasListener:(J)=>{return B.tabs.onZoomChange.hasListener(J)}}}var $=typeof browser<"u"&&browser.runtime,_=$?browser:chrome;function h(){if(typeof process<"u"&&process.env)return!0;if(typeof __webpack_require__<"u")try{if(process.env?.NODE_ENV!=="production")return!0}catch{}if(typeof globalThis<"u"){if(globalThis.__DEV__)return!0;if(globalThis.DEBUG)return!0}return!1}class M{_debug=!1;constructor(J){this._debug=J??h()}set debug(J){this._debug=J}get debug(){return this._debug}log(J,...X){if(this._debug)console.log(`[${J}]`,...X)}error(J,...X){if(this._debug)console.error(`[${J}]`,...X)}warn(J,...X){if(this._debug)console.warn(`[${J}]`,...X)}}function S(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}function KJ(J,X="Operation timed out"){return new Promise((Y,G)=>{setTimeout(()=>G(Error(X)),J)})}async function MJ(J,X,Y){return Promise.race([J,KJ(X,Y)])}function HJ(J){return new Promise((X)=>setTimeout(X,J))}class j extends M{cookieChangeListeners=new Set;browserListenerInitialized=!1;constructor(J=!1){super(J)}async get(J){try{if($)return await _.cookies.get(J);else return await _.cookies.get(J)}catch(X){return this.error("QevoCookies","Error getting cookie:",X),null}}async getAll(J){try{if($)return await _.cookies.getAll(J);else return await _.cookies.getAll(J)}catch(X){return this.error("QevoCookies","Error getting all cookies:",X),[]}}async set(J){try{if($)return await _.cookies.set(J);else return await _.cookies.set(J)}catch(X){return this.error("QevoCookies","Error setting cookie:",X),null}}async remove(J){try{if($)await _.cookies.remove(J);else await _.cookies.remove(J);return J}catch(X){throw this.error("QevoCookies","Error removing cookie:",X),X}}async getAllCookieStores(){try{if($)return await _.cookies.getAllCookieStores();else return await _.cookies.getAllCookieStores()}catch(J){return this.error("QevoCookies","Error getting cookie stores:",J),[]}}addListener(J){if(!this.cookieChangeListeners.has(J)){if(this.cookieChangeListeners.add(J),this.cookieChangeListeners.size===1&&!this.browserListenerInitialized)this.initializeBrowserListener()}}removeListener(J){this.cookieChangeListeners.delete(J)}hasListener(J){return this.cookieChangeListeners.has(J)}initializeBrowserListener(){if(this.browserListenerInitialized)return;let J=(X)=>{this.cookieChangeListeners.forEach((Y)=>{try{Y(X)}catch(G){this.error("QevoCookies","Error in cookie change listener:",G)}})};if($)_.cookies.onChanged.addListener(J);else _.cookies.onChanged.addListener(J);this.browserListenerInitialized=!0}get api(){return{get:this.get.bind(this),getAll:this.getAll.bind(this),set:this.set.bind(this),remove:this.remove.bind(this),getAllCookieStores:this.getAllCookieStores.bind(this),onChanged:{addListener:this.addListener.bind(this),removeListener:this.removeListener.bind(this),hasListener:this.hasListener.bind(this)}}}}class F extends M{messageListeners=new Map;listenerInitialized=!1;constructor(J=!1){super(J);this.initializeGlobalListener()}initializeGlobalListener(){if(this.listenerInitialized)return;_.runtime.onMessage.addListener((J,X,Y)=>{let{type:G,data:W,id:Z,timestamp:U}=J,H=Date.now();if(!G)return Y(this.createErrorResponse("Message type is required",Z,H-(U||H))),!1;let D=this.messageListeners.get(G);if(!D||D.length===0)return Y(this.createErrorResponse(`No listeners registered for message type: ${G}`,Z,H-(U||H))),!1;let C=!1,R=(L)=>{if(!C){C=!0;let N=Date.now()-H;Y(this.createSuccessResponse(L,Z,N))}};try{let L=D[0],N=L.constructor.name==="AsyncFunction",Q=L(W,X,R);if(Q&&typeof Q==="object"&&typeof Q.then==="function")return Q.then(()=>{}).catch((q)=>{if(this.error("QevoMessages","Error in async message listener:",q),!C){let zJ=Date.now()-H;Y(this.createErrorResponse(q instanceof Error?q.message:"Unknown error in message listener",Z,zJ))}}),!0;if(Q===!0)return!0;if(N)return!0;return!1}catch(L){if(this.error("QevoMessages","Error in message listener:",L),!C){let N=Date.now()-H;Y(this.createErrorResponse(L instanceof Error?L.message:"Unknown error in message listener",Z,N))}return!1}}),this.listenerInitialized=!0}on(J,X){if(!this.messageListeners.has(J))this.messageListeners.set(J,[]);this.messageListeners.get(J).push(X)}off(J,X){let Y=this.messageListeners.get(J);if(Y){let G=Y.indexOf(X);if(G>-1)Y.splice(G,1);if(Y.length===0)this.messageListeners.delete(J)}}clear(J){let X=this.messageListeners.get(J);if(X)X.length=0,this.messageListeners.delete(J)}getTypes(){return Array.from(this.messageListeners.keys())}hasListeners(J){let X=this.messageListeners.get(J);return!!(X&&X.length>0)}async sendToBackground(J,X,Y={}){let G=S(),W={type:J,data:X,id:G,timestamp:Date.now()};return this.sendWithRetry(()=>{if($)return _.runtime.sendMessage(W);else return _.runtime.sendMessage(W)},Y,G)}async sendToTab(J,X,Y,G={}){let W=S(),Z={type:X,data:Y,id:W,timestamp:Date.now()};return this.sendWithRetry(()=>_.tabs.sendMessage(J,Z),G,W)}async sendToAllTabs(J,X,Y={}){try{let W=(await _.tabs.query({})).map((Z)=>{if(Z.id)return this.sendToTab(Z.id,J,X,Y).catch((U)=>this.createErrorResponse(U.message,void 0,0));return Promise.resolve(this.createErrorResponse("Tab has no ID",void 0,0))});return Promise.all(W)}catch(G){return this.error("QevoMessages","Error sending to all tabs:",G),[this.createErrorResponse(G instanceof Error?G.message:"Failed to send to all tabs",void 0,0)]}}async broadcast(J,X,Y={}){return this.sendToAllTabs(J,X,Y)}async sendMessage(J,X,Y,G,W){if(J==="background"){let Z=X,U=Y,H=G;return this.sendToBackground(Z,U,H)}if(J==="tab"){let Z=X,U=Y,H=G;return this.sendToTab(Z,U,H,W)}if(J==="tabs"){let Z=X,U=Y,H=G;return this.sendToAllTabs(Z,U,H)}throw Error(`Invalid target: ${J}. Must be 'background', 'tab', or 'tabs'.`)}async sendWithRetry(J,X,Y){let{timeout:G=5000,retries:W=0,retryDelay:Z=1000}=X,U=Date.now(),H=null;for(let C=0;C<=W;C++)try{return await MJ(J(),G,"Message timeout")}catch(R){if(H=R instanceof Error?R:Error(String(R)),C<W)await HJ(Z)}let D=Date.now()-U;return this.createErrorResponse(H?.message||"Failed to send message after retries",Y,D)}createSuccessResponse(J,X,Y=0){return{success:!0,data:J,timestamp:Date.now(),messageId:X||S(),duration:Y}}createErrorResponse(J,X,Y=0){return{success:!1,error:J,timestamp:Date.now(),messageId:X||S(),duration:Y}}}class x extends M{webRequestListeners=new Map;simpleWebRequestListeners=new Map;maxListeners=10;constructor(J=!1){super(J)}on(J,X,Y,G){let Z={BeforeRequest:"onBeforeRequest",BeforeSendHeaders:"onBeforeSendHeaders",SendHeaders:"onSendHeaders",HeadersReceived:"onHeadersReceived",AuthRequired:"onAuthRequired",ResponseStarted:"onResponseStarted",BeforeRedirect:"onBeforeRedirect",Completed:"onCompleted",ErrorOccurred:"onErrorOccurred"}[J];if(!Z)throw Error(`Unsupported event type: ${J}`);if(!this.simpleWebRequestListeners.has(J))this.simpleWebRequestListeners.set(J,new Set);this.simpleWebRequestListeners.get(J).add(X),this.addListener(Z,X,Y,G)}off(J,X){let G={BeforeRequest:"onBeforeRequest",BeforeSendHeaders:"onBeforeSendHeaders",SendHeaders:"onSendHeaders",HeadersReceived:"onHeadersReceived",AuthRequired:"onAuthRequired",ResponseStarted:"onResponseStarted",BeforeRedirect:"onBeforeRedirect",Completed:"onCompleted",ErrorOccurred:"onErrorOccurred"}[J];if(!G)throw Error(`Unsupported event type: ${J}`);let W=this.simpleWebRequestListeners.get(J);if(W&&W.has(X)){if(W.delete(X),W.size===0)this.simpleWebRequestListeners.delete(J)}this.removeListener(G,X)}clear(J){let X=this.simpleWebRequestListeners.get(J);if(X){let Y=Array.from(X);for(let G of Y)this.off(J,G);X.clear()}}isAvailable(){try{return!!_.webRequest}catch{return!1}}getMaxListeners(){return this.maxListeners}setMaxListeners(J){this.maxListeners=J}addListener(J,X,Y,G){try{if(!this.isAvailable())throw Error("WebRequest API is not available in this context");let W=this.convertFilter(Y),Z=this.convertExtraInfoSpec(G);if(!this.webRequestListeners.has(J))this.webRequestListeners.set(J,new Set);if(this.webRequestListeners.get(J).add(X),$){let U=_;if(U.webRequest&&U.webRequest[J])U.webRequest[J].addListener(X,W,Z)}else{let U=_;if(U.webRequest&&U.webRequest[J])U.webRequest[J].addListener(X,W,Z)}}catch(W){throw this.error("QevoWebRequest",`Error adding listener for ${J}:`,W),W}}removeListener(J,X){try{let Y=this.webRequestListeners.get(J);if(Y&&Y.has(X))if(Y.delete(X),$){let G=_;if(G.webRequest&&G.webRequest[J])G.webRequest[J].removeListener(X)}else{let G=_;if(G.webRequest&&G.webRequest[J])G.webRequest[J].removeListener(X)}}catch(Y){throw this.error("QevoWebRequest",`Error removing listener for ${J}:`,Y),Y}}convertFilter(J){if($){let X={urls:J.urls};if(J.types)X.types=J.types;if(J.tabId!==void 0)X.tabId=J.tabId;if(J.windowId!==void 0)X.windowId=J.windowId;return X}return J}convertExtraInfoSpec(J){if(!J)return;if($)return J.map((X)=>{switch(X){case"asyncBlocking":return"blocking";case"extraHeaders":return"extraHeaders";default:return X}}).filter(Boolean);return J}get api(){return{on:this.on.bind(this),off:this.off.bind(this),clear:this.clear.bind(this),isAvailable:this.isAvailable.bind(this),getMaxListeners:this.getMaxListeners.bind(this)}}}class y extends M{alarmListeners=new Set;browserListenerInitialized=!1;constructor(J=!1){super(J)}async create(J,X){try{let Y,G;if(typeof J==="string")Y=J,G=X;else Y=void 0,G=J;if($)if(Y!==void 0)await _.alarms.create(Y,G);else await _.alarms.create(G);else if(Y!==void 0)await _.alarms.create(Y,G);else await _.alarms.create(G)}catch(Y){throw this.error("QevoAlarms","Error creating alarm:",Y),Y}}async get(J){try{if($)if(J!==void 0)return await _.alarms.get(J);else return await _.alarms.get();else if(J!==void 0)return await _.alarms.get(J);else return await _.alarms.get()}catch(X){this.error("QevoAlarms","Error getting alarm:",X);return}}async getAll(){try{if($)return await _.alarms.getAll();else return await _.alarms.getAll()}catch(J){return this.error("QevoAlarms","Error getting all alarms:",J),[]}}async clear(J){try{if($)if(J!==void 0)return await _.alarms.clear(J);else return await _.alarms.clear();else if(J!==void 0)return await _.alarms.clear(J);else return await _.alarms.clear()}catch(X){return this.error("QevoAlarms","Error clearing alarm:",X),!1}}async clearAll(){try{if($)return await _.alarms.clearAll();else return await _.alarms.clearAll()}catch(J){return this.error("QevoAlarms","Error clearing all alarms:",J),!1}}onAlarm(J){if(this.alarmListeners.add(J),!this.browserListenerInitialized)this.initializeBrowserListener()}offAlarm(J){this.alarmListeners.delete(J)}isAvailable(){try{return!!_.alarms}catch{return!1}}initializeBrowserListener(){if(this.browserListenerInitialized)return;let J=(X)=>{this.alarmListeners.forEach((Y)=>{try{Y(X)}catch(G){this.error("QevoAlarms","Error in alarm listener:",G)}})};if($)_.alarms.onAlarm.addListener(J);else _.alarms.onAlarm.addListener(J);this.browserListenerInitialized=!0}}class g extends M{clickedListeners=new Set;buttonClickedListeners=new Set;closedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async create(J,X){try{if($){let Y={type:J.type==="basic"?"basic":"basic",title:J.title,message:J.message,iconUrl:J.iconUrl};return await _.notifications.create(X||"",Y)}else return await _.notifications.create(X||"",J)}catch(Y){throw this.error("QevoNotifications","Error creating notification:",Y),Y}}async update(J,X){try{if($)return await _.notifications.update(J,X);else return await _.notifications.update(J,X)}catch(Y){return this.error("QevoNotifications","Error updating notification:",Y),!1}}async clear(J){try{if($)return await _.notifications.clear(J);else return await _.notifications.clear(J)}catch(X){return this.error("QevoNotifications","Error clearing notification:",X),!1}}async getAll(){try{if($)return await _.notifications.getAll();else return await _.notifications.getAll()}catch(J){return this.error("QevoNotifications","Error getting all notifications:",J),{}}}onClicked(J){this.clickedListeners.add(J),this.ensureListenersInitialized()}offClicked(J){this.clickedListeners.delete(J)}onButtonClicked(J){this.buttonClickedListeners.add(J),this.ensureListenersInitialized()}offButtonClicked(J){this.buttonClickedListeners.delete(J)}onClosed(J){this.closedListeners.add(J),this.ensureListenersInitialized()}offClosed(J){this.closedListeners.delete(J)}isAvailable(){try{return!!_.notifications}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;let J=(G)=>{this.clickedListeners.forEach((W)=>{try{W(G)}catch(Z){this.error("QevoNotifications","Error in clicked listener:",Z)}})},X=(G,W)=>{this.buttonClickedListeners.forEach((Z)=>{try{Z(G,W)}catch(U){this.error("QevoNotifications","Error in button clicked listener:",U)}})},Y=(G,W)=>{this.closedListeners.forEach((Z)=>{try{Z(G,W)}catch(U){this.error("QevoNotifications","Error in closed listener:",U)}})};if($){let G=_;G.notifications.onClicked.addListener(J),G.notifications.onClosed.addListener(Y)}else{let G=_;G.notifications.onClicked.addListener(J),G.notifications.onButtonClicked.addListener(X),G.notifications.onClosed.addListener(Y)}this.listenersInitialized=!0}}class k extends M{clickedListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}async create(J){return new Promise((X,Y)=>{try{if($){let G=_.contextMenus.create(J,()=>{let W=browser.runtime.lastError;if(W)Y(Error(W.message));else X(J.id||"")});if(G!==void 0)X(G)}else{let G=_.contextMenus.create(J,()=>{let W=chrome.runtime.lastError;if(W)Y(Error(W.message));else X(J.id||"")});if(G!==void 0&&!J.id)X(G)}}catch(G){this.error("QevoContextMenus","Error creating menu item:",G),Y(G)}})}async update(J,X){return new Promise((Y,G)=>{try{if($)_.contextMenus.update(J,X),Y();else _.contextMenus.update(J,X,()=>{let W=chrome.runtime.lastError;if(W)G(Error(W.message));else Y()})}catch(W){this.error("QevoContextMenus","Error updating menu item:",W),G(W)}})}async remove(J){return new Promise((X,Y)=>{try{if($)_.contextMenus.remove(J),X();else _.contextMenus.remove(J,()=>{let G=chrome.runtime.lastError;if(G)Y(Error(G.message));else X()})}catch(G){this.error("QevoContextMenus","Error removing menu item:",G),Y(G)}})}async removeAll(){return new Promise((J,X)=>{try{if($)_.contextMenus.removeAll(),J();else _.contextMenus.removeAll(()=>{let Y=chrome.runtime.lastError;if(Y)X(Error(Y.message));else J()})}catch(Y){this.error("QevoContextMenus","Error removing all menu items:",Y),X(Y)}})}onClicked(J){if(this.clickedListeners.add(J),!this.listenerInitialized)this.initializeBrowserListener()}offClicked(J){this.clickedListeners.delete(J)}isAvailable(){try{return!!_.contextMenus}catch{return!1}}initializeBrowserListener(){if(this.listenerInitialized)return;let J=(X,Y)=>{this.clickedListeners.forEach((G)=>{try{G(X,Y)}catch(W){this.error("QevoContextMenus","Error in click listener:",W)}})};if($)_.contextMenus.onClicked.addListener(J);else _.contextMenus.onClicked.addListener(J);this.listenerInitialized=!0}}class m extends M{constructor(J=!1){super(J)}async executeScript(J){try{if($)if(_.scripting)return await _.scripting.executeScript(J);else return(await _.tabs.executeScript(J.target.tabId,{file:J.files?.[0],code:J.func?`(${J.func.toString()})(${(J.args||[]).map((Y)=>JSON.stringify(Y)).join(",")})`:void 0,allFrames:J.target.allFrames,frameId:J.target.frameIds?.[0]})).map((Y,G)=>({frameId:J.target.frameIds?.[G]||0,result:Y}));else return await _.scripting.executeScript(J)}catch(X){throw this.error("QevoScripting","Error executing script:",X),X}}async insertCSS(J){try{if($)if(_.scripting)await _.scripting.insertCSS(J);else await _.tabs.insertCSS(J.target.tabId,{file:J.files?.[0],code:J.css,allFrames:J.target.allFrames,frameId:J.target.frameIds?.[0]});else await _.scripting.insertCSS(J)}catch(X){throw this.error("QevoScripting","Error inserting CSS:",X),X}}async removeCSS(J){try{if($)if(_.scripting)await _.scripting.removeCSS(J);else this.warn("QevoScripting","removeCSS not supported in Firefox MV2");else await _.scripting.removeCSS(J)}catch(X){throw this.error("QevoScripting","Error removing CSS:",X),X}}async registerContentScripts(J){try{if($)if(typeof _.scripting?.registerContentScripts==="function")await _.scripting.registerContentScripts(J);else this.warn("QevoScripting","registerContentScripts not available in this Firefox version");else await _.scripting.registerContentScripts(J)}catch(X){throw this.error("QevoScripting","Error registering content scripts:",X),X}}async unregisterContentScripts(J){try{if($){if(typeof _.scripting?.unregisterContentScripts==="function")await _.scripting.unregisterContentScripts(J)}else await _.scripting.unregisterContentScripts(J)}catch(X){throw this.error("QevoScripting","Error unregistering content scripts:",X),X}}async getRegisteredContentScripts(J){try{if($){if(typeof _.scripting?.getRegisteredContentScripts==="function")return await _.scripting.getRegisteredContentScripts(J);return[]}else return await _.scripting.getRegisteredContentScripts(J)}catch(X){return this.error("QevoScripting","Error getting registered content scripts:",X),[]}}async updateContentScripts(J){try{if($){if(typeof _.scripting?.updateContentScripts==="function")await _.scripting.updateContentScripts(J)}else await _.scripting.updateContentScripts(J)}catch(X){throw this.error("QevoScripting","Error updating content scripts:",X),X}}isAvailable(){try{return!!_.scripting}catch{return!1}}}class u extends M{clickedListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}getActionAPI(){if($){let J=_;return J.action||J.browserAction}else{let J=_;return J.action||J.browserAction}}async setBadgeText(J){try{let X=this.getActionAPI();if(X?.setBadgeText)await X.setBadgeText(J)}catch(X){throw this.error("QevoAction","Error setting badge text:",X),X}}async getBadgeText(J={}){try{let X=this.getActionAPI();if(X?.getBadgeText)return await X.getBadgeText(J);return""}catch(X){return this.error("QevoAction","Error getting badge text:",X),""}}async setBadgeBackgroundColor(J){try{let X=this.getActionAPI();if(X?.setBadgeBackgroundColor)await X.setBadgeBackgroundColor(J)}catch(X){throw this.error("QevoAction","Error setting badge color:",X),X}}async getBadgeBackgroundColor(J={}){try{let X=this.getActionAPI();if(X?.getBadgeBackgroundColor)return await X.getBadgeBackgroundColor(J);return[0,0,0,0]}catch(X){return this.error("QevoAction","Error getting badge color:",X),[0,0,0,0]}}async setBadgeTextColor(J){try{let X=this.getActionAPI();if(X?.setBadgeTextColor)await X.setBadgeTextColor(J)}catch(X){throw this.error("QevoAction","Error setting badge text color:",X),X}}async setIcon(J){try{let X=this.getActionAPI();if(X?.setIcon)await X.setIcon(J)}catch(X){throw this.error("QevoAction","Error setting icon:",X),X}}async setTitle(J){try{let X=this.getActionAPI();if(X?.setTitle)await X.setTitle(J)}catch(X){throw this.error("QevoAction","Error setting title:",X),X}}async getTitle(J={}){try{let X=this.getActionAPI();if(X?.getTitle)return await X.getTitle(J);return""}catch(X){return this.error("QevoAction","Error getting title:",X),""}}async setPopup(J){try{let X=this.getActionAPI();if(X?.setPopup)await X.setPopup(J)}catch(X){throw this.error("QevoAction","Error setting popup:",X),X}}async getPopup(J={}){try{let X=this.getActionAPI();if(X?.getPopup)return await X.getPopup(J);return""}catch(X){return this.error("QevoAction","Error getting popup:",X),""}}async enable(J){try{let X=this.getActionAPI();if(X?.enable)await X.enable(J)}catch(X){throw this.error("QevoAction","Error enabling action:",X),X}}async disable(J){try{let X=this.getActionAPI();if(X?.disable)await X.disable(J)}catch(X){throw this.error("QevoAction","Error disabling action:",X),X}}async isEnabled(J){try{let X=this.getActionAPI();if(X?.isEnabled)return await X.isEnabled(J?{tabId:J}:{});return!0}catch(X){return this.error("QevoAction","Error checking if enabled:",X),!0}}async openPopup(){try{let J=this.getActionAPI();if(J?.openPopup)await J.openPopup()}catch(J){throw this.error("QevoAction","Error opening popup:",J),J}}onClicked(J){if(this.clickedListeners.add(J),!this.listenerInitialized)this.initializeListener()}offClicked(J){this.clickedListeners.delete(J)}isAvailable(){try{return!!this.getActionAPI()}catch{return!1}}initializeListener(){if(this.listenerInitialized)return;let J=(Y)=>{this.clickedListeners.forEach((G)=>{try{G(Y)}catch(W){this.error("QevoAction","Error in click listener:",W)}})},X=this.getActionAPI();if(X?.onClicked)X.onClicked.addListener(J);this.listenerInitialized=!0}}class v extends M{focusChangedListeners=new Set;createdListeners=new Set;removedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async create(J){try{if($)return await _.windows.create(J);else return await _.windows.create(J)}catch(X){throw this.error("QevoWindows","Error creating window:",X),X}}async get(J,X){try{if($)return await _.windows.get(J,X);else return await _.windows.get(J,X)}catch(Y){throw this.error("QevoWindows","Error getting window:",Y),Y}}async getCurrent(J){try{if($)return await _.windows.getCurrent(J);else return await _.windows.getCurrent(J)}catch(X){throw this.error("QevoWindows","Error getting current window:",X),X}}async getLastFocused(J){try{if($)return await _.windows.getLastFocused(J);else return await _.windows.getLastFocused(J)}catch(X){throw this.error("QevoWindows","Error getting last focused window:",X),X}}async getAll(J){try{if($)return await _.windows.getAll(J);else return await _.windows.getAll(J)}catch(X){return this.error("QevoWindows","Error getting all windows:",X),[]}}async update(J,X){try{if($)return await _.windows.update(J,X);else return await _.windows.update(J,X)}catch(Y){throw this.error("QevoWindows","Error updating window:",Y),Y}}async remove(J){try{if($)await _.windows.remove(J);else await _.windows.remove(J)}catch(X){throw this.error("QevoWindows","Error removing window:",X),X}}get WINDOW_ID_NONE(){if($)return _.windows.WINDOW_ID_NONE;else return _.windows.WINDOW_ID_NONE}get WINDOW_ID_CURRENT(){if($)return _.windows.WINDOW_ID_CURRENT;else return _.windows.WINDOW_ID_CURRENT}onFocusChanged(J){this.focusChangedListeners.add(J),this.ensureListenersInitialized()}offFocusChanged(J){this.focusChangedListeners.delete(J)}onCreated(J){this.createdListeners.add(J),this.ensureListenersInitialized()}offCreated(J){this.createdListeners.delete(J)}onRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offRemoved(J){this.removedListeners.delete(J)}isAvailable(){try{return!!_.windows}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;let J=(G)=>{this.focusChangedListeners.forEach((W)=>{try{W(G)}catch(Z){this.error("QevoWindows","Error in focus listener:",Z)}})},X=(G)=>{this.createdListeners.forEach((W)=>{try{W(G)}catch(Z){this.error("QevoWindows","Error in created listener:",Z)}})},Y=(G)=>{this.removedListeners.forEach((W)=>{try{W(G)}catch(Z){this.error("QevoWindows","Error in removed listener:",Z)}})};if($){let G=_;G.windows.onFocusChanged.addListener(J),G.windows.onCreated.addListener(X),G.windows.onRemoved.addListener(Y)}else{let G=_;G.windows.onFocusChanged.addListener(J),G.windows.onCreated.addListener(X),G.windows.onRemoved.addListener(Y)}this.listenersInitialized=!0}}class f extends M{addedListeners=new Set;removedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async contains(J){try{if($)return await _.permissions.contains(J);else return await _.permissions.contains(J)}catch(X){return this.error("QevoPermissions","Error checking permissions:",X),!1}}async getAll(){try{if($)return await _.permissions.getAll();else return await _.permissions.getAll()}catch(J){return this.error("QevoPermissions","Error getting all permissions:",J),{}}}async request(J){try{if($)return await _.permissions.request(J);else return await _.permissions.request(J)}catch(X){return this.error("QevoPermissions","Error requesting permissions:",X),!1}}async remove(J){try{if($)return await _.permissions.remove(J);else return await _.permissions.remove(J)}catch(X){return this.error("QevoPermissions","Error removing permissions:",X),!1}}onAdded(J){this.addedListeners.add(J),this.ensureListenersInitialized()}offAdded(J){this.addedListeners.delete(J)}onRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offRemoved(J){this.removedListeners.delete(J)}isAvailable(){try{return!!_.permissions}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;let J=(Y)=>{this.addedListeners.forEach((G)=>{try{G(Y)}catch(W){this.error("QevoPermissions","Error in added listener:",W)}})},X=(Y)=>{this.removedListeners.forEach((G)=>{try{G(Y)}catch(W){this.error("QevoPermissions","Error in removed listener:",W)}})};if($){let Y=_;Y.permissions.onAdded.addListener(J),Y.permissions.onRemoved.addListener(X)}else{let Y=_;Y.permissions.onAdded.addListener(J),Y.permissions.onRemoved.addListener(X)}this.listenersInitialized=!0}}class A extends M{createdListeners=new Set;changedListeners=new Set;erasedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async download(J){try{if($)return await _.downloads.download(J);else return await _.downloads.download(J)}catch(X){throw this.error("QevoDownloads","Error downloading:",X),X}}async search(J){try{if($)return await _.downloads.search(J);else return await _.downloads.search(J)}catch(X){return this.error("QevoDownloads","Error searching downloads:",X),[]}}async pause(J){try{if($)await _.downloads.pause(J);else await _.downloads.pause(J)}catch(X){throw this.error("QevoDownloads","Error pausing download:",X),X}}async resume(J){try{if($)await _.downloads.resume(J);else await _.downloads.resume(J)}catch(X){throw this.error("QevoDownloads","Error resuming download:",X),X}}async cancel(J){try{if($)await _.downloads.cancel(J);else await _.downloads.cancel(J)}catch(X){throw this.error("QevoDownloads","Error canceling download:",X),X}}async erase(J){try{if($)return await _.downloads.erase(J);else return await _.downloads.erase(J)}catch(X){return this.error("QevoDownloads","Error erasing downloads:",X),[]}}async removeFile(J){try{if($)await _.downloads.removeFile(J);else await _.downloads.removeFile(J)}catch(X){throw this.error("QevoDownloads","Error removing file:",X),X}}async open(J){try{if($)await _.downloads.open(J);else await _.downloads.open(J)}catch(X){throw this.error("QevoDownloads","Error opening file:",X),X}}async show(J){try{if($)await _.downloads.show(J);else await _.downloads.show(J)}catch(X){throw this.error("QevoDownloads","Error showing file:",X),X}}async showDefaultFolder(){try{if($)await _.downloads.showDefaultFolder();else await _.downloads.showDefaultFolder()}catch(J){throw this.error("QevoDownloads","Error showing default folder:",J),J}}async getFileIcon(J,X){try{if($)if(X!==void 0)return await _.downloads.getFileIcon(J,X);else return await _.downloads.getFileIcon(J);else if(X!==void 0)return await _.downloads.getFileIcon(J,X);else return await _.downloads.getFileIcon(J)}catch(Y){throw this.error("QevoDownloads","Error getting file icon:",Y),Y}}onCreated(J){this.createdListeners.add(J),this.ensureListenersInitialized()}offCreated(J){this.createdListeners.delete(J)}onChanged(J){this.changedListeners.add(J),this.ensureListenersInitialized()}offChanged(J){this.changedListeners.delete(J)}onErased(J){this.erasedListeners.add(J),this.ensureListenersInitialized()}offErased(J){this.erasedListeners.delete(J)}isAvailable(){try{return!!_.downloads}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if($){let J=_;J.downloads.onCreated.addListener((X)=>{this.createdListeners.forEach((Y)=>Y(X))}),J.downloads.onChanged.addListener((X)=>{this.changedListeners.forEach((Y)=>Y(X))}),J.downloads.onErased.addListener((X)=>{this.erasedListeners.forEach((Y)=>Y(X))})}else{let J=_;J.downloads.onCreated.addListener((X)=>{this.createdListeners.forEach((Y)=>Y(X))}),J.downloads.onChanged.addListener((X)=>{this.changedListeners.forEach((Y)=>Y(X))}),J.downloads.onErased.addListener((X)=>{this.erasedListeners.forEach((Y)=>Y(X))})}this.listenersInitialized=!0}}class P extends M{visitedListeners=new Set;removedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async search(J){try{if($)return await _.history.search(J);else return await _.history.search(J)}catch(X){return this.error("QevoHistory","Error searching history:",X),[]}}async getVisits(J){try{if($)return await _.history.getVisits(J);else return await _.history.getVisits(J)}catch(X){return this.error("QevoHistory","Error getting visits:",X),[]}}async addUrl(J){try{if($)await _.history.addUrl(J);else await _.history.addUrl(J)}catch(X){throw this.error("QevoHistory","Error adding URL:",X),X}}async deleteUrl(J){try{if($)await _.history.deleteUrl(J);else await _.history.deleteUrl(J)}catch(X){throw this.error("QevoHistory","Error deleting URL:",X),X}}async deleteRange(J){try{if($)await _.history.deleteRange(J);else await _.history.deleteRange(J)}catch(X){throw this.error("QevoHistory","Error deleting range:",X),X}}async deleteAll(){try{if($)await _.history.deleteAll();else await _.history.deleteAll()}catch(J){throw this.error("QevoHistory","Error deleting all history:",J),J}}onVisited(J){this.visitedListeners.add(J),this.ensureListenersInitialized()}offVisited(J){this.visitedListeners.delete(J)}onVisitRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offVisitRemoved(J){this.removedListeners.delete(J)}isAvailable(){try{return!!_.history}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if($){let J=_;J.history.onVisited.addListener((X)=>{this.visitedListeners.forEach((Y)=>Y(X))}),J.history.onVisitRemoved.addListener((X)=>{this.removedListeners.forEach((Y)=>Y(X))})}else{let J=_;J.history.onVisited.addListener((X)=>{this.visitedListeners.forEach((Y)=>Y(X))}),J.history.onVisitRemoved.addListener((X)=>{this.removedListeners.forEach((Y)=>Y(X))})}this.listenersInitialized=!0}}class w extends M{createdListeners=new Set;removedListeners=new Set;changedListeners=new Set;movedListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}async getTree(){try{if($)return await _.bookmarks.getTree();else return await _.bookmarks.getTree()}catch(J){return this.error("QevoBookmarks","Error getting tree:",J),[]}}async getSubTree(J){try{if($)return await _.bookmarks.getSubTree(J);else return await _.bookmarks.getSubTree(J)}catch(X){return this.error("QevoBookmarks","Error getting subtree:",X),[]}}async get(J){try{if($)return await _.bookmarks.get(J);else return await _.bookmarks.get(J)}catch(X){return this.error("QevoBookmarks","Error getting bookmarks:",X),[]}}async getChildren(J){try{if($)return await _.bookmarks.getChildren(J);else return await _.bookmarks.getChildren(J)}catch(X){return this.error("QevoBookmarks","Error getting children:",X),[]}}async getRecent(J){try{if($)return await _.bookmarks.getRecent(J);else return await _.bookmarks.getRecent(J)}catch(X){return this.error("QevoBookmarks","Error getting recent:",X),[]}}async search(J){try{if($)return await _.bookmarks.search(J);else return await _.bookmarks.search(J)}catch(X){return this.error("QevoBookmarks","Error searching:",X),[]}}async create(J){try{if($)return await _.bookmarks.create(J);else return await _.bookmarks.create(J)}catch(X){throw this.error("QevoBookmarks","Error creating bookmark:",X),X}}async update(J,X){try{if($)return await _.bookmarks.update(J,X);else return await _.bookmarks.update(J,X)}catch(Y){throw this.error("QevoBookmarks","Error updating bookmark:",Y),Y}}async move(J,X){try{if($)return await _.bookmarks.move(J,X);else return await _.bookmarks.move(J,X)}catch(Y){throw this.error("QevoBookmarks","Error moving bookmark:",Y),Y}}async remove(J){try{if($)await _.bookmarks.remove(J);else await _.bookmarks.remove(J)}catch(X){throw this.error("QevoBookmarks","Error removing bookmark:",X),X}}async removeTree(J){try{if($)await _.bookmarks.removeTree(J);else await _.bookmarks.removeTree(J)}catch(X){throw this.error("QevoBookmarks","Error removing tree:",X),X}}onCreated(J){this.createdListeners.add(J),this.ensureListenersInitialized()}offCreated(J){this.createdListeners.delete(J)}onRemoved(J){this.removedListeners.add(J),this.ensureListenersInitialized()}offRemoved(J){this.removedListeners.delete(J)}onChanged(J){this.changedListeners.add(J),this.ensureListenersInitialized()}offChanged(J){this.changedListeners.delete(J)}onMoved(J){this.movedListeners.add(J),this.ensureListenersInitialized()}offMoved(J){this.movedListeners.delete(J)}isAvailable(){try{return!!_.bookmarks}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if($){let J=_;J.bookmarks.onCreated.addListener((X,Y)=>{this.createdListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onRemoved.addListener((X,Y)=>{this.removedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onChanged.addListener((X,Y)=>{this.changedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onMoved.addListener((X,Y)=>{this.movedListeners.forEach((G)=>G(X,Y))})}else{let J=_;J.bookmarks.onCreated.addListener((X,Y)=>{this.createdListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onRemoved.addListener((X,Y)=>{this.removedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onChanged.addListener((X,Y)=>{this.changedListeners.forEach((G)=>G(X,Y))}),J.bookmarks.onMoved.addListener((X,Y)=>{this.movedListeners.forEach((G)=>G(X,Y))})}this.listenersInitialized=!0}}class p extends M{constructor(J=!1){super(J)}async getAuthToken(J={}){try{if($){this.warn("QevoIdentity","getAuthToken not available in Firefox, use launchWebAuthFlow");return}else{let X=await _.identity.getAuthToken(J);return typeof X==="string"?X:X?.token}}catch(X){throw this.error("QevoIdentity","Error getting auth token:",X),X}}async removeCachedAuthToken(J){try{if($)this.warn("QevoIdentity","removeCachedAuthToken not available in Firefox");else await _.identity.removeCachedAuthToken(J)}catch(X){throw this.error("QevoIdentity","Error removing cached token:",X),X}}async clearAllCachedAuthTokens(){try{if($)this.warn("QevoIdentity","clearAllCachedAuthTokens not available in Firefox");else if(typeof _.identity.clearAllCachedAuthTokens==="function")await _.identity.clearAllCachedAuthTokens()}catch(J){throw this.error("QevoIdentity","Error clearing cached tokens:",J),J}}async launchWebAuthFlow(J){try{if($)return await _.identity.launchWebAuthFlow(J);else return await _.identity.launchWebAuthFlow(J)||""}catch(X){throw this.error("QevoIdentity","Error launching web auth flow:",X),X}}getRedirectURL(J){try{if($)return _.identity.getRedirectURL(J);else return _.identity.getRedirectURL(J)}catch(X){throw this.error("QevoIdentity","Error getting redirect URL:",X),X}}async getProfileUserInfo(){try{if($){this.warn("QevoIdentity","getProfileUserInfo not available in Firefox");return}else return await _.identity.getProfileUserInfo({})}catch(J){this.error("QevoIdentity","Error getting profile info:",J);return}}async getAccounts(){try{if($)return[];else if(typeof _.identity.getAccounts==="function")return await _.identity.getAccounts();return[]}catch(J){return this.error("QevoIdentity","Error getting accounts:",J),[]}}isAvailable(){try{return!!_.identity}catch{return!1}}}class c extends M{commandListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}async getAll(){try{if($)return await _.commands.getAll();else return await _.commands.getAll()}catch(J){return this.error("QevoCommands","Error getting commands:",J),[]}}onCommand(J){if(this.commandListeners.add(J),!this.listenerInitialized)this.initializeListener()}offCommand(J){this.commandListeners.delete(J)}isAvailable(){try{return!!_.commands}catch{return!1}}initializeListener(){if(this.listenerInitialized)return;let J=(X,Y)=>{this.commandListeners.forEach((G)=>{try{G(X,Y)}catch(W){this.error("QevoCommands","Error in command listener:",W)}})};if($)_.commands.onCommand.addListener(J);else _.commands.onCommand.addListener(J);this.listenerInitialized=!0}}class d extends M{constructor(J=!1){super(J)}getMessage(J,X){try{if($)return _.i18n.getMessage(J,X);else return _.i18n.getMessage(J,X)}catch(Y){return this.error("QevoI18n","Error getting message:",Y),""}}getUILanguage(){try{if($)return _.i18n.getUILanguage();else return _.i18n.getUILanguage()}catch(J){return this.error("QevoI18n","Error getting UI language:",J),"en"}}async getAcceptLanguages(){try{if($)return await _.i18n.getAcceptLanguages();else return await _.i18n.getAcceptLanguages()}catch(J){return this.error("QevoI18n","Error getting accept languages:",J),[]}}async detectLanguage(J){try{if($)return await _.i18n.detectLanguage(J);else return await _.i18n.detectLanguage(J)}catch(X){return this.error("QevoI18n","Error detecting language:",X),{isReliable:!1,languages:[]}}}isAvailable(){try{return!!_.i18n}catch{return!1}}}class I extends M{stateChangedListeners=new Set;listenerInitialized=!1;constructor(J=!1){super(J)}async queryState(J){try{if($)return await _.idle.queryState(J);else return await _.idle.queryState(J)}catch(X){return this.error("QevoIdle","Error querying state:",X),"active"}}setDetectionInterval(J){try{if($)_.idle.setDetectionInterval(J);else _.idle.setDetectionInterval(J)}catch(X){this.error("QevoIdle","Error setting detection interval:",X)}}async getAutoLockDelay(){try{if($)return 0;else if(typeof _.idle.getAutoLockDelay==="function")return await _.idle.getAutoLockDelay();return 0}catch(J){return this.error("QevoIdle","Error getting auto-lock delay:",J),0}}onStateChanged(J){if(this.stateChangedListeners.add(J),!this.listenerInitialized)this.initializeListener()}offStateChanged(J){this.stateChangedListeners.delete(J)}isAvailable(){try{return!!_.idle}catch{return!1}}initializeListener(){if(this.listenerInitialized)return;let J=(X)=>{this.stateChangedListeners.forEach((Y)=>{try{Y(X)}catch(G){this.error("QevoIdle","Error in state change listener:",G)}})};if($)_.idle.onStateChanged.addListener(J);else _.idle.onStateChanged.addListener(J);this.listenerInitialized=!0}}class b extends M{installedListeners=new Set;startupListeners=new Set;suspendListeners=new Set;connectListeners=new Set;updateAvailableListeners=new Set;listenersInitialized=!1;constructor(J=!1){super(J)}get id(){return _.runtime.id}getManifest(){return _.runtime.getManifest()}getURL(J){return _.runtime.getURL(J)}async getPlatformInfo(){try{if($)return await _.runtime.getPlatformInfo();else return await _.runtime.getPlatformInfo()}catch(J){throw this.error("QevoRuntime","Error getting platform info:",J),J}}async openOptionsPage(){try{if($)await _.runtime.openOptionsPage();else await _.runtime.openOptionsPage()}catch(J){throw this.error("QevoRuntime","Error opening options page:",J),J}}reload(){_.runtime.reload()}async requestUpdateCheck(){try{if($)return{status:"no_update"};else return await _.runtime.requestUpdateCheck()}catch(J){return this.error("QevoRuntime","Error requesting update check:",J),{status:"error"}}}async setUninstallURL(J){try{if($)await _.runtime.setUninstallURL(J);else await _.runtime.setUninstallURL(J)}catch(X){throw this.error("QevoRuntime","Error setting uninstall URL:",X),X}}connect(J,X){if($){if(typeof J==="string")return _.runtime.connect(J,X);return _.runtime.connect(J||{})}else{if(typeof J==="string")return _.runtime.connect(J,X);return _.runtime.connect(J||{})}}connectNative(J){if($)return _.runtime.connectNative(J);else return _.runtime.connectNative(J)}get lastError(){return _.runtime.lastError}onInstalled(J){this.installedListeners.add(J),this.ensureListenersInitialized()}offInstalled(J){this.installedListeners.delete(J)}onStartup(J){this.startupListeners.add(J),this.ensureListenersInitialized()}offStartup(J){this.startupListeners.delete(J)}onSuspend(J){this.suspendListeners.add(J),this.ensureListenersInitialized()}offSuspend(J){this.suspendListeners.delete(J)}onConnect(J){this.connectListeners.add(J),this.ensureListenersInitialized()}offConnect(J){this.connectListeners.delete(J)}onUpdateAvailable(J){this.updateAvailableListeners.add(J),this.ensureListenersInitialized()}offUpdateAvailable(J){this.updateAvailableListeners.delete(J)}isAvailable(){try{return!!_.runtime}catch{return!1}}ensureListenersInitialized(){if(this.listenersInitialized)return;if($){let J=_;if(J.runtime.onInstalled.addListener((X)=>{this.installedListeners.forEach((Y)=>Y(X))}),J.runtime.onStartup.addListener(()=>{this.startupListeners.forEach((X)=>X())}),J.runtime.onSuspend)J.runtime.onSuspend.addListener(()=>{this.suspendListeners.forEach((X)=>X())});if(J.runtime.onConnect.addListener((X)=>{this.connectListeners.forEach((Y)=>Y(X))}),J.runtime.onUpdateAvailable)J.runtime.onUpdateAvailable.addListener((X)=>{this.updateAvailableListeners.forEach((Y)=>Y(X))})}else{let J=_;if(J.runtime.onInstalled.addListener((X)=>{this.installedListeners.forEach((Y)=>Y(X))}),J.runtime.onStartup.addListener(()=>{this.startupListeners.forEach((X)=>X())}),J.runtime.onSuspend)J.runtime.onSuspend.addListener(()=>{this.suspendListeners.forEach((X)=>X())});J.runtime.onConnect.addListener((X)=>{this.connectListeners.forEach((Y)=>Y(X))}),J.runtime.onUpdateAvailable.addListener((X)=>{this.updateAvailableListeners.forEach((Y)=>Y(X))})}this.listenersInitialized=!0}}class n extends M{listeners=new Map;nativeListeners=new Map;constructor(J=!1){super(J)}on(J,X,Y){let W={BeforeNavigate:"onBeforeNavigate",Committed:"onCommitted",DOMContentLoaded:"onDOMContentLoaded",Completed:"onCompleted",ErrorOccurred:"onErrorOccurred",CreatedNavigationTarget:"onCreatedNavigationTarget",ReferenceFragmentUpdated:"onReferenceFragmentUpdated",TabReplaced:"onTabReplaced",HistoryStateUpdated:"onHistoryStateUpdated"}[J];if(!W)throw Error(`Unsupported event type: ${J}`);if(!this.listeners.has(J))this.listeners.set(J,new Set);this.listeners.get(J).add(X);try{if(!this.isAvailable())throw Error("WebNavigation API is not available");let Z=_.webNavigation;if(Z&&Z[W]){let U=(D)=>{X(D)},H=`${J}_${X.toString().slice(0,50)}`;if(this.nativeListeners.set(H,U),Y)Z[W].addListener(U,Y);else Z[W].addListener(U)}}catch(Z){throw this.error("QevoWebNavigation",`Error adding listener for ${J}:`,Z),Z}}off(J,X){let G={BeforeNavigate:"onBeforeNavigate",Committed:"onCommitted",DOMContentLoaded:"onDOMContentLoaded",Completed:"onCompleted",ErrorOccurred:"onErrorOccurred",CreatedNavigationTarget:"onCreatedNavigationTarget",ReferenceFragmentUpdated:"onReferenceFragmentUpdated",TabReplaced:"onTabReplaced",HistoryStateUpdated:"onHistoryStateUpdated"}[J];if(!G)return;let W=this.listeners.get(J);if(W){if(W.delete(X),W.size===0)this.listeners.delete(J)}try{let Z=_.webNavigation,U=`${J}_${X.toString().slice(0,50)}`,H=this.nativeListeners.get(U);if(Z&&Z[G]&&H)Z[G].removeListener(H),this.nativeListeners.delete(U)}catch(Z){this.error("QevoWebNavigation",`Error removing listener for ${J}:`,Z)}}clear(J){let X=this.listeners.get(J);if(X){let Y=Array.from(X);for(let G of Y)this.off(J,G)}}isAvailable(){try{return!!_.webNavigation}catch{return!1}}async getAllFrames(J){try{if($)return await _.webNavigation.getAllFrames(J);else return await _.webNavigation.getAllFrames(J)}catch(X){return this.error("QevoWebNavigation","Error getting all frames:",X),null}}async getFrame(J){try{if($)return await _.webNavigation.getFrame(J);else return await _.webNavigation.getFrame(J)}catch(X){return this.error("QevoWebNavigation","Error getting frame:",X),null}}get api(){return{on:this.on.bind(this),off:this.off.bind(this),clear:this.clear.bind(this),isAvailable:this.isAvailable.bind(this),getAllFrames:this.getAllFrames.bind(this),getFrame:this.getFrame.bind(this)}}}class l extends M{listeners=new Map;constructor(J=!1){super(J)}get DYNAMIC_RULESET_ID(){return _.declarativeNetRequest.DYNAMIC_RULESET_ID||"_dynamic"}get SESSION_RULESET_ID(){return _.declarativeNetRequest.SESSION_RULESET_ID||"_session"}get GUARANTEED_MINIMUM_STATIC_RULES(){return _.declarativeNetRequest.GUARANTEED_MINIMUM_STATIC_RULES||30000}get MAX_NUMBER_OF_STATIC_RULESETS(){return _.declarativeNetRequest.MAX_NUMBER_OF_STATIC_RULESETS||100}get MAX_NUMBER_OF_ENABLED_STATIC_RULESETS(){return _.declarativeNetRequest.MAX_NUMBER_OF_ENABLED_STATIC_RULESETS||50}get MAX_NUMBER_OF_DYNAMIC_RULES(){return _.declarativeNetRequest.MAX_NUMBER_OF_DYNAMIC_RULES||30000}get MAX_NUMBER_OF_SESSION_RULES(){return _.declarativeNetRequest.MAX_NUMBER_OF_SESSION_RULES||5000}get MAX_NUMBER_OF_REGEX_RULES(){return _.declarativeNetRequest.MAX_NUMBER_OF_REGEX_RULES||1000}get MAX_NUMBER_OF_DISABLED_STATIC_RULES(){return _.declarativeNetRequest.MAX_NUMBER_OF_DISABLED_STATIC_RULES||5000}async updateDynamicRules(J){try{if($)await _.declarativeNetRequest.updateDynamicRules(J);else await _.declarativeNetRequest.updateDynamicRules(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error updating dynamic rules:",X),X}}async getDynamicRules(){try{if($)return await _.declarativeNetRequest.getDynamicRules();else return await _.declarativeNetRequest.getDynamicRules()}catch(J){throw this.error("QevoDeclarativeNetRequest","Error getting dynamic rules:",J),J}}async updateSessionRules(J){try{if($)await _.declarativeNetRequest.updateSessionRules(J);else await _.declarativeNetRequest.updateSessionRules(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error updating session rules:",X),X}}async getSessionRules(){try{if($)return await _.declarativeNetRequest.getSessionRules();else return await _.declarativeNetRequest.getSessionRules()}catch(J){throw this.error("QevoDeclarativeNetRequest","Error getting session rules:",J),J}}async updateEnabledRulesets(J){try{if($)await _.declarativeNetRequest.updateEnabledRulesets(J);else await _.declarativeNetRequest.updateEnabledRulesets(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error updating enabled rulesets:",X),X}}async getEnabledRulesets(){try{if($)return await _.declarativeNetRequest.getEnabledRulesets();else return await _.declarativeNetRequest.getEnabledRulesets()}catch(J){throw this.error("QevoDeclarativeNetRequest","Error getting enabled rulesets:",J),J}}async getAvailableStaticRuleCount(){try{if($)return await _.declarativeNetRequest.getAvailableStaticRuleCount();else return await _.declarativeNetRequest.getAvailableStaticRuleCount()}catch(J){throw this.error("QevoDeclarativeNetRequest","Error getting available static rule count:",J),J}}async updateStaticRules(J){try{if($)await _.declarativeNetRequest.updateStaticRules(J);else await _.declarativeNetRequest.updateStaticRules(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error updating static rules:",X),X}}async getDisabledRuleIds(J){try{if($)return await _.declarativeNetRequest.getDisabledRuleIds(J);else return await _.declarativeNetRequest.getDisabledRuleIds(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error getting disabled rule IDs:",X),X}}async getMatchedRules(J){try{if($)throw Error("getMatchedRules is not supported in Firefox");else return await _.declarativeNetRequest.getMatchedRules(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error getting matched rules:",X),X}}async testMatchOutcome(J){try{if($)return await _.declarativeNetRequest.testMatchOutcome(J);else return await _.declarativeNetRequest.testMatchOutcome(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error testing match outcome:",X),X}}async isRegexSupported(J){try{if($)return await _.declarativeNetRequest.isRegexSupported(J);else return await _.declarativeNetRequest.isRegexSupported(J)}catch(X){throw this.error("QevoDeclarativeNetRequest","Error checking regex support:",X),X}}on(J,X){if(J!=="RuleMatchedDebug")throw Error(`Unsupported event type: ${J}`);if(!this.listeners.has(J))this.listeners.set(J,new Set);this.listeners.get(J).add(X);try{let Y=_.declarativeNetRequest;if(Y?.onRuleMatchedDebug)Y.onRuleMatchedDebug.addListener(X)}catch(Y){this.error("QevoDeclarativeNetRequest","Error adding listener:",Y)}}off(J,X){let Y=this.listeners.get(J);if(Y)Y.delete(X);try{let G=_.declarativeNetRequest;if(G?.onRuleMatchedDebug)G.onRuleMatchedDebug.removeListener(X)}catch(G){this.error("QevoDeclarativeNetRequest","Error removing listener:",G)}}isAvailable(){try{return!!_.declarativeNetRequest}catch{return!1}}get api(){return{updateDynamicRules:this.updateDynamicRules.bind(this),getDynamicRules:this.getDynamicRules.bind(this),updateSessionRules:this.updateSessionRules.bind(this),getSessionRules:this.getSessionRules.bind(this),updateEnabledRulesets:this.updateEnabledRulesets.bind(this),getEnabledRulesets:this.getEnabledRulesets.bind(this),getAvailableStaticRuleCount:this.getAvailableStaticRuleCount.bind(this),getMatchedRules:this.getMatchedRules.bind(this),testMatchOutcome:this.testMatchOutcome.bind(this),isRegexSupported:this.isRegexSupported.bind(this),on:this.on.bind(this),off:this.off.bind(this),isAvailable:this.isAvailable.bind(this)}}}class a extends M{constructor(J=!1){super(J)}isAvailable(){try{return typeof _.devtools<"u"}catch{return!1}}get inspectedWindow(){let J=this;return{get tabId(){try{return _.devtools.inspectedWindow.tabId}catch{return-1}},eval:(X,Y,G)=>{let W,Z;if(typeof Y==="function")Z=Y,W=void 0;else if(typeof G==="function")W=Y,Z=G;else W=Y;if(Z){try{if($)_.devtools.inspectedWindow.eval(X,W).then((U)=>{Z(U,void 0)}).catch((U)=>{Z(void 0,{isError:!0,code:"E_EVAL",description:String(U),details:[],isException:!0,value:String(U)})});else if(W)_.devtools.inspectedWindow.eval(X,W,(U,H)=>{Z(U,H)});else _.devtools.inspectedWindow.eval(X,(U,H)=>{Z(U,H)})}catch(U){J.error("QevoDevtools","Error evaluating expression:",U),Z(void 0,{isError:!0,code:"E_EVAL",description:String(U),details:[],isException:!1})}return}return new Promise((U)=>{try{if($)_.devtools.inspectedWindow.eval(X,W).then((H)=>{U([H,void 0])}).catch((H)=>{U([void 0,{isError:!0,code:"E_EVAL",description:String(H),details:[],isException:!0,value:String(H)}])});else if(W)_.devtools.inspectedWindow.eval(X,W,(H,D)=>{U([H,D])});else _.devtools.inspectedWindow.eval(X,(H,D)=>{U([H,D])})}catch(H){J.error("QevoDevtools","Error evaluating expression:",H),U([void 0,{isError:!0,code:"E_EVAL",description:String(H),details:[],isException:!1}])}})},async reload(X){try{if(X)_.devtools.inspectedWindow.reload(X);else _.devtools.inspectedWindow.reload()}catch(Y){J.error("QevoDevtools","Error reloading inspected window:",Y)}},async getResources(){return new Promise((X)=>{try{_.devtools.inspectedWindow.getResources((Y)=>{X(Y||[])})}catch(Y){J.error("QevoDevtools","Error getting resources:",Y),X([])}})},onResourceAdded:{addListener(X){try{_.devtools.inspectedWindow.onResourceAdded.addListener(X)}catch(Y){J.error("QevoDevtools","Error adding onResourceAdded listener:",Y)}},removeListener(X){try{_.devtools.inspectedWindow.onResourceAdded.removeListener(X)}catch(Y){J.error("QevoDevtools","Error removing onResourceAdded listener:",Y)}}},onResourceContentCommitted:{addListener(X){try{_.devtools.inspectedWindow.onResourceContentCommitted.addListener(X)}catch(Y){J.error("QevoDevtools","Error adding onResourceContentCommitted listener:",Y)}},removeListener(X){try{_.devtools.inspectedWindow.onResourceContentCommitted.removeListener(X)}catch(Y){J.error("QevoDevtools","Error removing onResourceContentCommitted listener:",Y)}}}}}get panels(){let J=this;return{get themeName(){try{return _.devtools.panels.themeName||"default"}catch{return"default"}},async create(X,Y,G){return new Promise((W,Z)=>{try{_.devtools.panels.create(X,Y,G,(U)=>{if(U)W(U);else Z(Error("Failed to create panel"))})}catch(U){J.error("QevoDevtools","Error creating panel:",U),Z(U)}})},setOpenResourceHandler(X){try{_.devtools.panels.setOpenResourceHandler(X)}catch(Y){J.error("QevoDevtools","Error setting open resource handler:",Y)}},openResource(X,Y,G){try{if(G)_.devtools.panels.openResource(X,Y,G);else _.devtools.panels.openResource(X,Y)}catch(W){J.error("QevoDevtools","Error opening resource:",W)}},get elements(){return{async createSidebarPane(X){return new Promise((Y,G)=>{try{_.devtools.panels.elements.createSidebarPane(X,(W)=>{if(W)Y(W);else G(Error("Failed to create sidebar pane"))})}catch(W){J.error("QevoDevtools","Error creating sidebar pane:",W),G(W)}})},onSelectionChanged:{addListener(X){try{_.devtools.panels.elements.onSelectionChanged.addListener(X)}catch(Y){J.error("QevoDevtools","Error adding onSelectionChanged listener:",Y)}},removeListener(X){try{_.devtools.panels.elements.onSelectionChanged.removeListener(X)}catch(Y){J.error("QevoDevtools","Error removing onSelectionChanged listener:",Y)}}}}},get sources(){return{async createSidebarPane(X){return new Promise((Y,G)=>{try{_.devtools.panels.sources.createSidebarPane(X,(W)=>{if(W)Y(W);else G(Error("Failed to create sidebar pane"))})}catch(W){J.error("QevoDevtools","Error creating sidebar pane:",W),G(W)}})}}},onThemeChanged:{addListener(X){try{_.devtools.panels.onThemeChanged?.addListener(X)}catch(Y){J.error("QevoDevtools","Error adding onThemeChanged listener:",Y)}},removeListener(X){try{_.devtools.panels.onThemeChanged?.removeListener(X)}catch(Y){J.error("QevoDevtools","Error removing onThemeChanged listener:",Y)}}}}}get network(){let J=this;return{async getHAR(){return new Promise((X)=>{try{_.devtools.network.getHAR((Y)=>{X(Y)})}catch(Y){J.error("QevoDevtools","Error getting HAR:",Y),X({version:"1.2",creator:{name:"qevo",version:"1.0"},entries:[]})}})},onRequestFinished:{addListener(X){try{_.devtools.network.onRequestFinished.addListener(X)}catch(Y){J.error("QevoDevtools","Error adding onRequestFinished listener:",Y)}},removeListener(X){try{_.devtools.network.onRequestFinished.removeListener(X)}catch(Y){J.error("QevoDevtools","Error removing onRequestFinished listener:",Y)}}},onNavigated:{addListener(X){try{_.devtools.network.onNavigated.addListener(X)}catch(Y){J.error("QevoDevtools","Error adding onNavigated listener:",Y)}},removeListener(X){try{_.devtools.network.onNavigated.removeListener(X)}catch(Y){J.error("QevoDevtools","Error removing onNavigated listener:",Y)}}}}}}class i extends M{constructor(J=!1){super(J)}isAvailable(){try{return!!_.management}catch{return!1}}async getAll(){try{if($)return await _.management.getAll();else return await _.management.getAll()}catch(J){throw this.error("QevoManagement","Error getting all extensions:",J),J}}async get(J){try{if($)return await _.management.get(J);else return await _.management.get(J)}catch(X){throw this.error("QevoManagement","Error getting extension:",X),X}}async getSelf(){try{if($)return await _.management.getSelf();else return await _.management.getSelf()}catch(J){throw this.error("QevoManagement","Error getting self:",J),J}}async getPermissionWarningsById(J){try{if($)return[];else return await _.management.getPermissionWarningsById(J)}catch(X){return this.error("QevoManagement","Error getting permission warnings:",X),[]}}async setEnabled(J,X){try{if($)await _.management.setEnabled(J,X);else await _.management.setEnabled(J,X)}catch(Y){throw this.error("QevoManagement","Error setting enabled state:",Y),Y}}async uninstall(J,X){try{if($)throw Error("management.uninstall() is not supported in Firefox. Use uninstallSelf() instead.");if(X)await _.management.uninstall(J,X);else await _.management.uninstall(J)}catch(Y){throw this.error("QevoManagement","Error uninstalling extension:",Y),Y}}async uninstallSelf(J){try{if($)await _.management.uninstallSelf(J);else if(J)await _.management.uninstallSelf(J);else await _.management.uninstallSelf()}catch(X){throw this.error("QevoManagement","Error uninstalling self:",X),X}}async launchApp(J){try{if($)throw Error("management.launchApp() is not supported in Firefox. Chrome apps are not available.");await _.management.launchApp(J)}catch(X){throw this.error("QevoManagement","Error launching app:",X),X}}async createAppShortcut(J){try{if($)throw Error("management.createAppShortcut() is not supported in Firefox. Chrome apps are not available.");await _.management.createAppShortcut(J)}catch(X){throw this.error("QevoManagement","Error creating app shortcut:",X),X}}async setLaunchType(J,X){try{if($)throw Error("management.setLaunchType() is not supported in Firefox. Chrome apps are not available.");await _.management.setLaunchType(J,X)}catch(Y){throw this.error("QevoManagement","Error setting launch type:",Y),Y}}async generateAppForLink(J,X){try{if($)throw Error("management.generateAppForLink() is not supported in Firefox. Chrome apps are not available.");return await _.management.generateAppForLink(J,X)}catch(Y){throw this.error("QevoManagement","Error generating app for link:",Y),Y}}get onInstalled(){let J=this;return{addListener(X){try{_.management.onInstalled.addListener(X)}catch(Y){J.error("QevoManagement","Error adding onInstalled listener:",Y)}},removeListener(X){try{_.management.onInstalled.removeListener(X)}catch(Y){J.error("QevoManagement","Error removing onInstalled listener:",Y)}}}}get onUninstalled(){let J=this;return{addListener(X){try{_.management.onUninstalled.addListener(X)}catch(Y){J.error("QevoManagement","Error adding onUninstalled listener:",Y)}},removeListener(X){try{_.management.onUninstalled.removeListener(X)}catch(Y){J.error("QevoManagement","Error removing onUninstalled listener:",Y)}}}}get onEnabled(){let J=this;return{addListener(X){try{_.management.onEnabled.addListener(X)}catch(Y){J.error("QevoManagement","Error adding onEnabled listener:",Y)}},removeListener(X){try{_.management.onEnabled.removeListener(X)}catch(Y){J.error("QevoManagement","Error removing onEnabled listener:",Y)}}}}get onDisabled(){let J=this;return{addListener(X){try{_.management.onDisabled.addListener(X)}catch(Y){J.error("QevoManagement","Error adding onDisabled listener:",Y)}},removeListener(X){try{_.management.onDisabled.removeListener(X)}catch(Y){J.error("QevoManagement","Error removing onDisabled listener:",Y)}}}}}class t extends M{constructor(J=!1){super(J)}isAvailable(){try{return!!_.sessions}catch{return!1}}get MAX_SESSION_RESULTS(){try{return _.sessions.MAX_SESSION_RESULTS||25}catch{return 25}}async getRecentlyClosed(J){try{if($)if(J)return await _.sessions.getRecentlyClosed(J);else return await _.sessions.getRecentlyClosed();else if(J)return await _.sessions.getRecentlyClosed(J);else return await _.sessions.getRecentlyClosed()}catch(X){throw this.error("QevoSessions","Error getting recently closed:",X),X}}async getDevices(J){try{if($)return[];else if(J)return await _.sessions.getDevices(J);else return await _.sessions.getDevices()}catch(X){return this.error("QevoSessions","Error getting devices:",X),[]}}async restore(J){try{if($)if(J)return await _.sessions.restore(J);else return await _.sessions.restore();else if(J)return await _.sessions.restore(J);else return await _.sessions.restore()}catch(X){throw this.error("QevoSessions","Error restoring session:",X),X}}async forgetClosedTab(J,X){try{if(!$)throw Error("sessions.forgetClosedTab() is not supported in Chrome.");await _.sessions.forgetClosedTab(J,X)}catch(Y){throw this.error("QevoSessions","Error forgetting closed tab:",Y),Y}}async forgetClosedWindow(J){try{if(!$)throw Error("sessions.forgetClosedWindow() is not supported in Chrome.");await _.sessions.forgetClosedWindow(J)}catch(X){throw this.error("QevoSessions","Error forgetting closed window:",X),X}}async setTabValue(J,X,Y){try{if(!$)throw Error("sessions.setTabValue() is not supported in Chrome.");await _.sessions.setTabValue(J,X,Y)}catch(G){throw this.error("QevoSessions","Error setting tab value:",G),G}}async getTabValue(J,X){try{if(!$)throw Error("sessions.getTabValue() is not supported in Chrome.");return await _.sessions.getTabValue(J,X)}catch(Y){throw this.error("QevoSessions","Error getting tab value:",Y),Y}}async removeTabValue(J,X){try{if(!$)throw Error("sessions.removeTabValue() is not supported in Chrome.");await _.sessions.removeTabValue(J,X)}catch(Y){throw this.error("QevoSessions","Error removing tab value:",Y),Y}}async setWindowValue(J,X,Y){try{if(!$)throw Error("sessions.setWindowValue() is not supported in Chrome.");await _.sessions.setWindowValue(J,X,Y)}catch(G){throw this.error("QevoSessions","Error setting window value:",G),G}}async getWindowValue(J,X){try{if(!$)throw Error("sessions.getWindowValue() is not supported in Chrome.");return await _.sessions.getWindowValue(J,X)}catch(Y){throw this.error("QevoSessions","Error getting window value:",Y),Y}}async removeWindowValue(J,X){try{if(!$)throw Error("sessions.removeWindowValue() is not supported in Chrome.");await _.sessions.removeWindowValue(J,X)}catch(Y){throw this.error("QevoSessions","Error removing window value:",Y),Y}}get onChanged(){let J=this;return{addListener(X){try{_.sessions.onChanged.addListener(X)}catch(Y){J.error("QevoSessions","Error adding onChanged listener:",Y)}},removeListener(X){try{_.sessions.onChanged.removeListener(X)}catch(Y){J.error("QevoSessions","Error removing onChanged listener:",Y)}}}}}class s extends M{requestListeners=new Set;constructor(J=!1){super(J)}isAvailable(){try{return!!_.proxy}catch{return!1}}get settings(){let J=this;return{async get(X){try{if($)return await _.proxy.settings.get(X);else return await new Promise((Y)=>{_.proxy.settings.get(X,(G)=>{Y(G)})})}catch(Y){throw J.error("QevoProxy","Error getting proxy settings:",Y),Y}},async set(X){try{if($)await _.proxy.settings.set(X);else return await new Promise((Y,G)=>{_.proxy.settings.set(X,()=>{if(chrome.runtime.lastError)G(Error(chrome.runtime.lastError.message));else Y()})})}catch(Y){throw J.error("QevoProxy","Error setting proxy settings:",Y),Y}},async clear(X){try{if($)await _.proxy.settings.clear(X||{});else return await new Promise((Y,G)=>{_.proxy.settings.clear(X||{},()=>{if(chrome.runtime.lastError)G(Error(chrome.runtime.lastError.message));else Y()})})}catch(Y){throw J.error("QevoProxy","Error clearing proxy settings:",Y),Y}}}}onRequest(J){if(!$){this.log("QevoProxy","onRequest is only available in Firefox");return}this.requestListeners.add(J);try{_.proxy.onRequest.addListener(J,{urls:["<all_urls>"]})}catch(X){this.error("QevoProxy","Error adding onRequest listener:",X)}}offRequest(J){if(!$)return;this.requestListeners.delete(J);try{_.proxy.onRequest.removeListener(J)}catch(X){this.error("QevoProxy","Error removing onRequest listener:",X)}}get onProxyError(){let J=this;return{addListener(X){try{if($)_.proxy.onError.addListener(X);else _.proxy.onProxyError.addListener(X)}catch(Y){J.error("QevoProxy","Error adding onProxyError listener:",Y)}},removeListener(X){try{if($)_.proxy.onError.removeListener(X);else _.proxy.onProxyError.removeListener(X)}catch(Y){J.error("QevoProxy","Error removing onProxyError listener:",Y)}}}}}class o extends M{constructor(J=!1){super(J)}isAvailable(){try{return!!_.browsingData}catch{return!1}}async settings(){try{if($)return await _.browsingData.settings();else return await new Promise((J)=>{_.browsingData.settings((X)=>{J(X)})})}catch(J){throw this.error("QevoBrowsingData","Error getting settings:",J),J}}async remove(J,X){try{if($)await _.browsingData.remove(J,X);else await _.browsingData.remove(J,X)}catch(Y){throw this.error("QevoBrowsingData","Error removing browsing data:",Y),Y}}async removeCache(J){try{if($)await _.browsingData.removeCache(J);else await _.browsingData.removeCache(J)}catch(X){throw this.error("QevoBrowsingData","Error removing cache:",X),X}}async removeCookies(J){try{if($)await _.browsingData.removeCookies(J);else await _.browsingData.removeCookies(J)}catch(X){throw this.error("QevoBrowsingData","Error removing cookies:",X),X}}async removeDownloads(J){try{if($)await _.browsingData.removeDownloads(J);else await _.browsingData.removeDownloads(J)}catch(X){throw this.error("QevoBrowsingData","Error removing downloads:",X),X}}async removeFormData(J){try{if($)await _.browsingData.removeFormData(J);else await _.browsingData.removeFormData(J)}catch(X){throw this.error("QevoBrowsingData","Error removing form data:",X),X}}async removeHistory(J){try{if($)await _.browsingData.removeHistory(J);else await _.browsingData.removeHistory(J)}catch(X){throw this.error("QevoBrowsingData","Error removing history:",X),X}}async removeLocalStorage(J){try{if($)await _.browsingData.removeLocalStorage(J);else await _.browsingData.removeLocalStorage(J)}catch(X){throw this.error("QevoBrowsingData","Error removing local storage:",X),X}}async removePasswords(J){try{if($)await _.browsingData.removePasswords(J);else await _.browsingData.removePasswords(J)}catch(X){throw this.error("QevoBrowsingData","Error removing passwords:",X),X}}async removePluginData(J){try{if($)await _.browsingData.removePluginData(J);else await _.browsingData.removePluginData(J)}catch(X){throw this.error("QevoBrowsingData","Error removing plugin data:",X),X}}async removeServiceWorkers(J){try{if($)await _.browsingData.remove(J,{serviceWorkers:!0});else await _.browsingData.removeServiceWorkers(J)}catch(X){throw this.error("QevoBrowsingData","Error removing service workers:",X),X}}async removeCacheStorage(J){try{if($)throw Error("removeCacheStorage is not supported in Firefox");await _.browsingData.removeCacheStorage(J)}catch(X){throw this.error("QevoBrowsingData","Error removing cache storage:",X),X}}async removeIndexedDB(J){try{if($)await _.browsingData.remove(J,{indexedDB:!0});else await _.browsingData.removeIndexedDB(J)}catch(X){throw this.error("QevoBrowsingData","Error removing IndexedDB:",X),X}}async removeFileSystems(J){try{if($)return;await _.browsingData.removeFileSystems(J)}catch(X){throw this.error("QevoBrowsingData","Error removing file systems:",X),X}}async removeWebSQL(J){try{if($)return;await _.browsingData.removeWebSQL(J)}catch(X){throw this.error("QevoBrowsingData","Error removing WebSQL:",X),X}}async removeAppcache(J){try{if($)return;await _.browsingData.removeAppcache(J)}catch(X){throw this.error("QevoBrowsingData","Error removing appcache:",X),X}}}class r extends M{constructor(J=!1){super(J)}isAvailable(){try{return!$&&!!_.sidePanel}catch{return!1}}async setOptions(J){try{if(!this.isAvailable())throw Error("SidePanel API is not available");await _.sidePanel.setOptions(J)}catch(X){throw this.error("QevoSidePanel","Error setting side panel options:",X),X}}async getOptions(J){try{if(!this.isAvailable())throw Error("SidePanel API is not available");return await _.sidePanel.getOptions(J)}catch(X){throw this.error("QevoSidePanel","Error getting side panel options:",X),X}}async open(J){try{if(!this.isAvailable())throw Error("SidePanel API is not available");await _.sidePanel.open(J)}catch(X){throw this.error("QevoSidePanel","Error opening side panel:",X),X}}async setPanelBehavior(J){try{if(!this.isAvailable())throw Error("SidePanel API is not available");await _.sidePanel.setPanelBehavior(J)}catch(X){throw this.error("QevoSidePanel","Error setting panel behavior:",X),X}}async getPanelBehavior(){try{if(!this.isAvailable())throw Error("SidePanel API is not available");return await _.sidePanel.getPanelBehavior()}catch(J){throw this.error("QevoSidePanel","Error getting panel behavior:",J),J}}}class e extends M{constructor(J=!1){super(J)}isAvailable(){try{return!$&&!!_.offscreen}catch{return!1}}async createDocument(J){try{if(!this.isAvailable())throw Error("Offscreen API is not available");await _.offscreen.createDocument(J)}catch(X){throw this.error("QevoOffscreen","Error creating offscreen document:",X),X}}async hasDocument(){try{if(!this.isAvailable())return!1;if(_.offscreen.hasDocument)return await _.offscreen.hasDocument();try{return(await _.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"]})).length>0}catch{return!1}}catch(J){return this.error("QevoOffscreen","Error checking for offscreen document:",J),!1}}async closeDocument(){try{if(!this.isAvailable())throw Error("Offscreen API is not available");await _.offscreen.closeDocument()}catch(J){throw this.error("QevoOffscreen","Error closing offscreen document:",J),J}}async ensureDocument(J){if(!await this.hasDocument())await this.createDocument(J)}}class JJ extends M{constructor(J=!1){super(J)}isAvailable(){try{return!!_.omnibox}catch{return!1}}setDefaultSuggestion(J){try{_.omnibox.setDefaultSuggestion(J)}catch(X){this.error("QevoOmnibox","Error setting default suggestion:",X)}}onInputStarted(J){try{_.omnibox.onInputStarted.addListener(J)}catch(X){this.error("QevoOmnibox","Error adding onInputStarted listener:",X)}}offInputStarted(J){try{_.omnibox.onInputStarted.removeListener(J)}catch(X){this.error("QevoOmnibox","Error removing onInputStarted listener:",X)}}onInputChanged(J){try{_.omnibox.onInputChanged.addListener(J)}catch(X){this.error("QevoOmnibox","Error adding onInputChanged listener:",X)}}offInputChanged(J){try{_.omnibox.onInputChanged.removeListener(J)}catch(X){this.error("QevoOmnibox","Error removing onInputChanged listener:",X)}}onInputEntered(J){try{_.omnibox.onInputEntered.addListener(J)}catch(X){this.error("QevoOmnibox","Error adding onInputEntered listener:",X)}}offInputEntered(J){try{_.omnibox.onInputEntered.removeListener(J)}catch(X){this.error("QevoOmnibox","Error removing onInputEntered listener:",X)}}onInputCancelled(J){try{_.omnibox.onInputCancelled.addListener(J)}catch(X){this.error("QevoOmnibox","Error adding onInputCancelled listener:",X)}}offInputCancelled(J){try{_.omnibox.onInputCancelled.removeListener(J)}catch(X){this.error("QevoOmnibox","Error removing onInputCancelled listener:",X)}}onDeleteSuggestion(J){try{if(!$&&_.omnibox.onDeleteSuggestion)_.omnibox.onDeleteSuggestion.addListener(J)}catch(X){this.error("QevoOmnibox","Error adding onDeleteSuggestion listener:",X)}}offDeleteSuggestion(J){try{if(!$&&_.omnibox.onDeleteSuggestion)_.omnibox.onDeleteSuggestion.removeListener(J)}catch(X){this.error("QevoOmnibox","Error removing onDeleteSuggestion listener:",X)}}}class XJ extends M{constructor(J=!1){super(J)}isAvailable(){try{return!!_.topSites}catch{return!1}}async get(){try{if($)return await _.topSites.get();else return await _.topSites.get()}catch(J){throw this.error("QevoTopSites","Error getting top sites:",J),J}}}class YJ extends M{constructor(J=!1){super(J)}isAvailable(){try{return!!_.tts}catch{return!1}}async speak(J,X){return new Promise((Y,G)=>{try{let W=()=>{if(chrome?.runtime?.lastError)G(Error(chrome.runtime.lastError.message));else Y()};if(X)_.tts.speak(J,X,W);else _.tts.speak(J,W)}catch(W){this.error("QevoTts","Error speaking:",W),G(W)}})}stop(){try{_.tts.stop()}catch(J){this.error("QevoTts","Error stopping speech:",J)}}pause(){try{if(!$)_.tts.pause()}catch(J){this.error("QevoTts","Error pausing speech:",J)}}resume(){try{if(!$)_.tts.resume()}catch(J){this.error("QevoTts","Error resuming speech:",J)}}async isSpeaking(){return new Promise((J)=>{try{_.tts.isSpeaking((X)=>{J(X||!1)})}catch(X){this.error("QevoTts","Error checking speaking status:",X),J(!1)}})}async getVoices(){return new Promise((J)=>{try{_.tts.getVoices((X)=>{J(X||[])})}catch(X){this.error("QevoTts","Error getting voices:",X),J([])}})}get onVoicesChanged(){let J=this;return{addListener(X){try{if(!$&&_.tts.onVoicesChanged)_.tts.onVoicesChanged.addListener(X)}catch(Y){J.error("QevoTts","Error adding onVoicesChanged listener:",Y)}},removeListener(X){try{if(!$&&_.tts.onVoicesChanged)_.tts.onVoicesChanged.removeListener(X)}catch(Y){J.error("QevoTts","Error removing onVoicesChanged listener:",Y)}}}}}function K(J,X){return{async get(Y){return new Promise((G,W)=>{try{J.get(Y,(Z)=>{if(chrome?.runtime?.lastError)W(Error(chrome.runtime.lastError.message));else G(Z)})}catch(Z){W(Z)}})},async set(Y){return new Promise((G,W)=>{try{J.set(Y,()=>{if(chrome?.runtime?.lastError)W(Error(chrome.runtime.lastError.message));else G()})}catch(Z){W(Z)}})},async clear(Y){return new Promise((G,W)=>{try{J.clear(Y||{},()=>{if(chrome?.runtime?.lastError)W(Error(chrome.runtime.lastError.message));else G()})}catch(Z){W(Z)}})},onChange:{addListener(Y){try{J.onChange?.addListener(Y)}catch(G){if(X.debug)console.error("[QevoPrivacy]","Error adding onChange listener:",G)}},removeListener(Y){try{J.onChange?.removeListener(Y)}catch(G){if(X.debug)console.error("[QevoPrivacy]","Error removing onChange listener:",G)}}}}}class _J extends M{constructor(J=!1){super(J)}isAvailable(){try{return!!_.privacy}catch{return!1}}get network(){let J=this,X=_.privacy?.network;return{get networkPredictionEnabled(){return K(X?.networkPredictionEnabled,J)},get webRTCIPHandlingPolicy(){return K(X?.webRTCIPHandlingPolicy,J)}}}get services(){let J=this,X=_.privacy?.services;return{get alternateErrorPagesEnabled(){return K(X?.alternateErrorPagesEnabled,J)},get autofillEnabled(){return K(X?.autofillEnabled,J)},get autofillAddressEnabled(){return K(X?.autofillAddressEnabled,J)},get autofillCreditCardEnabled(){return K(X?.autofillCreditCardEnabled,J)},get passwordSavingEnabled(){return K(X?.passwordSavingEnabled,J)},get safeBrowsingEnabled(){return K(X?.safeBrowsingEnabled,J)},get safeBrowsingExtendedReportingEnabled(){return K(X?.safeBrowsingExtendedReportingEnabled,J)},get searchSuggestEnabled(){return K(X?.searchSuggestEnabled,J)},get spellingServiceEnabled(){return K(X?.spellingServiceEnabled,J)},get translationServiceEnabled(){return K(X?.translationServiceEnabled,J)}}}get websites(){let J=this,X=_.privacy?.websites;return{get thirdPartyCookiesAllowed(){return K(X?.thirdPartyCookiesAllowed,J)},get hyperlinkAuditingEnabled(){return K(X?.hyperlinkAuditingEnabled,J)},get referrersEnabled(){return K(X?.referrersEnabled,J)},get doNotTrackEnabled(){return K(X?.doNotTrackEnabled,J)},get protectedContentEnabled(){return K(X?.protectedContentEnabled,J)},get cookieConfig(){return K(X?.cookieConfig,J)},get firstPartyIsolate(){return K(X?.firstPartyIsolate,J)},get resistFingerprinting(){return K(X?.resistFingerprinting,J)},get trackingProtectionMode(){return K(X?.trackingProtectionMode,J)}}}}class GJ extends M{constructor(J=!1){super(J)}isAvailable(){try{return!$&&!!_.pageCapture}catch{return!1}}async saveAsMHTML(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("PageCapture API is not available"));return}_.pageCapture.saveAsMHTML(J,(G)=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else if(G)X(G);else Y(Error("Failed to capture page"))})}catch(G){this.error("QevoPageCapture","Error saving as MHTML:",G),Y(G)}})}}class $J extends M{constructor(J=!1){super(J)}isAvailable(){try{return!$&&!!_.fontSettings}catch{return!1}}async getFontList(){return new Promise((J,X)=>{try{if(!this.isAvailable()){X(Error("FontSettings API is not available"));return}_.fontSettings.getFontList((Y)=>{if(chrome.runtime.lastError)X(Error(chrome.runtime.lastError.message));else J(Y||[])})}catch(Y){this.error("QevoFontSettings","Error getting font list:",Y),X(Y)}})}async getFont(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.getFont(J,(G)=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X(G)})}catch(G){this.error("QevoFontSettings","Error getting font:",G),Y(G)}})}async setFont(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.setFont(J,()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error setting font:",G),Y(G)}})}async clearFont(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.clearFont(J,()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error clearing font:",G),Y(G)}})}async getDefaultFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.getDefaultFontSize(J,(G)=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X(G)})}catch(G){this.error("QevoFontSettings","Error getting default font size:",G),Y(G)}})}async setDefaultFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.setDefaultFontSize(J,()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error setting default font size:",G),Y(G)}})}async clearDefaultFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.clearDefaultFontSize(J||{},()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error clearing default font size:",G),Y(G)}})}async getDefaultFixedFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.getDefaultFixedFontSize(J,(G)=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X(G)})}catch(G){this.error("QevoFontSettings","Error getting default fixed font size:",G),Y(G)}})}async setDefaultFixedFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.setDefaultFixedFontSize(J,()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error setting default fixed font size:",G),Y(G)}})}async clearDefaultFixedFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.clearDefaultFixedFontSize(J||{},()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error clearing default fixed font size:",G),Y(G)}})}async getMinimumFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.getMinimumFontSize(J,(G)=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X(G)})}catch(G){this.error("QevoFontSettings","Error getting minimum font size:",G),Y(G)}})}async setMinimumFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.setMinimumFontSize(J,()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error setting minimum font size:",G),Y(G)}})}async clearMinimumFontSize(J){return new Promise((X,Y)=>{try{if(!this.isAvailable()){Y(Error("FontSettings API is not available"));return}_.fontSettings.clearMinimumFontSize(J||{},()=>{if(chrome.runtime.lastError)Y(Error(chrome.runtime.lastError.message));else X()})}catch(G){this.error("QevoFontSettings","Error clearing minimum font size:",G),Y(G)}})}get onFontChanged(){let J=this;return{addListener(X){try{if(J.isAvailable())_.fontSettings.onFontChanged.addListener(X)}catch(Y){J.error("QevoFontSettings","Error adding onFontChanged listener:",Y)}},removeListener(X){try{if(J.isAvailable())_.fontSettings.onFontChanged.removeListener(X)}catch(Y){J.error("QevoFontSettings","Error removing onFontChanged listener:",Y)}}}}get onDefaultFontSizeChanged(){let J=this;return{addListener(X){try{if(J.isAvailable())_.fontSettings.onDefaultFontSizeChanged.addListener(X)}catch(Y){J.error("QevoFontSettings","Error adding onDefaultFontSizeChanged listener:",Y)}},removeListener(X){try{if(J.isAvailable())_.fontSettings.onDefaultFontSizeChanged.removeListener(X)}catch(Y){J.error("QevoFontSettings","Error removing onDefaultFontSizeChanged listener:",Y)}}}}get onDefaultFixedFontSizeChanged(){let J=this;return{addListener(X){try{if(J.isAvailable())_.fontSettings.onDefaultFixedFontSizeChanged.addListener(X)}catch(Y){J.error("QevoFontSettings","Error adding onDefaultFixedFontSizeChanged listener:",Y)}},removeListener(X){try{if(J.isAvailable())_.fontSettings.onDefaultFixedFontSizeChanged.removeListener(X)}catch(Y){J.error("QevoFontSettings","Error removing onDefaultFixedFontSizeChanged listener:",Y)}}}}get onMinimumFontSizeChanged(){let J=this;return{addListener(X){try{if(J.isAvailable())_.fontSettings.onMinimumFontSizeChanged.addListener(X)}catch(Y){J.error("QevoFontSettings","Error adding onMinimumFontSizeChanged listener:",Y)}},removeListener(X){try{if(J.isAvailable())_.fontSettings.onMinimumFontSizeChanged.removeListener(X)}catch(Y){J.error("QevoFontSettings","Error removing onMinimumFontSizeChanged listener:",Y)}}}}}class V{static instance;_debug;_tabsInstance;_cookiesInstance;_messagesInstance;_webRequestInstance;_alarmsInstance;_notificationsInstance;_contextMenusInstance;_scriptingInstance;_actionInstance;_windowsInstance;_permissionsInstance;_downloadsInstance;_historyInstance;_bookmarksInstance;_identityInstance;_commandsInstance;_i18nInstance;_idleInstance;_runtimeInstance;_webNavigationInstance;_declarativeNetRequestInstance;_devtoolsInstance;_managementInstance;_sessionsInstance;_proxyInstance;_browsingDataInstance;_sidePanelInstance;_offscreenInstance;_omniboxInstance;_topSitesInstance;_ttsInstance;_privacyInstance;_pageCaptureInstance;_fontSettingsInstance;constructor(){this._debug=h(),this.log("\uD83D\uDE80 Qevo initialized")}set debug(J){if(this._debug=J,this._tabsInstance)this._tabsInstance.debug=J;if(this._cookiesInstance)this._cookiesInstance.debug=J;if(this._messagesInstance)this._messagesInstance.debug=J;if(this._webRequestInstance)this._webRequestInstance.debug=J;if(this._alarmsInstance)this._alarmsInstance.debug=J;if(this._notificationsInstance)this._notificationsInstance.debug=J;if(this._contextMenusInstance)this._contextMenusInstance.debug=J;if(this._scriptingInstance)this._scriptingInstance.debug=J;if(this._actionInstance)this._actionInstance.debug=J;if(this._windowsInstance)this._windowsInstance.debug=J;if(this._permissionsInstance)this._permissionsInstance.debug=J;if(this._downloadsInstance)this._downloadsInstance.debug=J;if(this._historyInstance)this._historyInstance.debug=J;if(this._bookmarksInstance)this._bookmarksInstance.debug=J;if(this._identityInstance)this._identityInstance.debug=J;if(this._commandsInstance)this._commandsInstance.debug=J;if(this._i18nInstance)this._i18nInstance.debug=J;if(this._idleInstance)this._idleInstance.debug=J;if(this._runtimeInstance)this._runtimeInstance.debug=J;if(this._webNavigationInstance)this._webNavigationInstance.debug=J;if(this._declarativeNetRequestInstance)this._declarativeNetRequestInstance.debug=J;if(this._devtoolsInstance)this._devtoolsInstance.debug=J;if(this._managementInstance)this._managementInstance.debug=J;if(this._sessionsInstance)this._sessionsInstance.debug=J;if(this._proxyInstance)this._proxyInstance.debug=J;if(this._browsingDataInstance)this._browsingDataInstance.debug=J;if(this._sidePanelInstance)this._sidePanelInstance.debug=J;if(this._offscreenInstance)this._offscreenInstance.debug=J;if(this._omniboxInstance)this._omniboxInstance.debug=J;if(this._topSitesInstance)this._topSitesInstance.debug=J;if(this._ttsInstance)this._ttsInstance.debug=J;if(this._privacyInstance)this._privacyInstance.debug=J;if(this._pageCaptureInstance)this._pageCaptureInstance.debug=J;if(this._fontSettingsInstance)this._fontSettingsInstance.debug=J;this.log(`\uD83D\uDD27 Debug mode: ${J?"ENABLED":"DISABLED"}`)}get debug(){return this._debug}get tabs(){if(!this._tabsInstance)this._tabsInstance=new T(this._debug);return this._tabsInstance}get cookies(){if(!this._cookiesInstance)this._cookiesInstance=new j(this._debug);return this._cookiesInstance}get messages(){if(!this._messagesInstance)this._messagesInstance=new F(this._debug);return this._messagesInstance}get webRequest(){if(!this._webRequestInstance)this._webRequestInstance=new x(this._debug);return this._webRequestInstance}get storage(){return UJ}get alarms(){if(!this._alarmsInstance)this._alarmsInstance=new y(this._debug);return this._alarmsInstance}get notifications(){if(!this._notificationsInstance)this._notificationsInstance=new g(this._debug);return this._notificationsInstance}get contextMenus(){if(!this._contextMenusInstance)this._contextMenusInstance=new k(this._debug);return this._contextMenusInstance}get scripting(){if(!this._scriptingInstance)this._scriptingInstance=new m(this._debug);return this._scriptingInstance}get action(){if(!this._actionInstance)this._actionInstance=new u(this._debug);return this._actionInstance}get windows(){if(!this._windowsInstance)this._windowsInstance=new v(this._debug);return this._windowsInstance}get permissions(){if(!this._permissionsInstance)this._permissionsInstance=new f(this._debug);return this._permissionsInstance}get downloads(){if(!this._downloadsInstance)this._downloadsInstance=new A(this._debug);return this._downloadsInstance}get history(){if(!this._historyInstance)this._historyInstance=new P(this._debug);return this._historyInstance}get bookmarks(){if(!this._bookmarksInstance)this._bookmarksInstance=new w(this._debug);return this._bookmarksInstance}get identity(){if(!this._identityInstance)this._identityInstance=new p(this._debug);return this._identityInstance}get commands(){if(!this._commandsInstance)this._commandsInstance=new c(this._debug);return this._commandsInstance}get i18n(){if(!this._i18nInstance)this._i18nInstance=new d(this._debug);return this._i18nInstance}get idle(){if(!this._idleInstance)this._idleInstance=new I(this._debug);return this._idleInstance}get runtime(){if(!this._runtimeInstance)this._runtimeInstance=new b(this._debug);return this._runtimeInstance}get webNavigation(){if(!this._webNavigationInstance)this._webNavigationInstance=new n(this._debug);return this._webNavigationInstance}get declarativeNetRequest(){if(!this._declarativeNetRequestInstance)this._declarativeNetRequestInstance=new l(this._debug);return this._declarativeNetRequestInstance}get devtools(){if(!this._devtoolsInstance)this._devtoolsInstance=new a(this._debug);return this._devtoolsInstance}get management(){if(!this._managementInstance)this._managementInstance=new i(this._debug);return this._managementInstance}get sessions(){if(!this._sessionsInstance)this._sessionsInstance=new t(this._debug);return this._sessionsInstance}get proxy(){if(!this._proxyInstance)this._proxyInstance=new s(this._debug);return this._proxyInstance}get browsingData(){if(!this._browsingDataInstance)this._browsingDataInstance=new o(this._debug);return this._browsingDataInstance}get sidePanel(){if(!this._sidePanelInstance)this._sidePanelInstance=new r(this._debug);return this._sidePanelInstance}get offscreen(){if(!this._offscreenInstance)this._offscreenInstance=new e(this._debug);return this._offscreenInstance}get omnibox(){if(!this._omniboxInstance)this._omniboxInstance=new JJ(this._debug);return this._omniboxInstance}get topSites(){if(!this._topSitesInstance)this._topSitesInstance=new XJ(this._debug);return this._topSitesInstance}get tts(){if(!this._ttsInstance)this._ttsInstance=new YJ(this._debug);return this._ttsInstance}get privacy(){if(!this._privacyInstance)this._privacyInstance=new _J(this._debug);return this._privacyInstance}get pageCapture(){if(!this._pageCaptureInstance)this._pageCaptureInstance=new GJ(this._debug);return this._pageCaptureInstance}get fontSettings(){if(!this._fontSettingsInstance)this._fontSettingsInstance=new $J(this._debug);return this._fontSettingsInstance}isBackgroundScript(){try{return!!_.runtime?.getManifest()?.background}catch{return!1}}isContentScript(){return typeof window<"u"&&window.location!==void 0}getBrowserType(){if(typeof browser<"u"&&browser.runtime)return"firefox";if(typeof chrome<"u")return"chrome";return"unknown"}log(...J){if(this._debug)console.log("[Qevo]",...J)}static getInstance(){if(!V.instance)V.instance=new V;return V.instance}}var z=V.getInstance(),eY=z,KY=z.isBackgroundScript.bind(z),DY=z.isContentScript.bind(z),CY=z.getBrowserType.bind(z),RY=z.storage,LY=z.cookies,VY=z.tabs,NY=z.webRequest,QY=z.messages,SY=z.alarms,OY=z.notifications,qY=z.contextMenus,TY=z.scripting,hY=z.action,jY=z.windows,FY=z.permissions,xY=z.downloads,yY=z.history,gY=z.bookmarks,kY=z.identity,mY=z.commands,uY=z.i18n,vY=z.idle,fY=z.runtime,AY=z.webNavigation,PY=z.declarativeNetRequest,wY=z.devtools,pY=z.management,cY=z.sessions,dY=z.proxy,IY=z.browsingData,bY=z.sidePanel,nY=z.offscreen,lY=z.omnibox,aY=z.topSites,iY=z.tts,tY=z.privacy,sY=z.pageCapture,oY=z.fontSettings;export{jY as windows,NY as webRequest,AY as webNavigation,iY as tts,aY as topSites,VY as tabs,RY as storage,bY as sidePanel,cY as sessions,TY as scripting,fY as runtime,z as qevo,dY as proxy,tY as privacy,FY as permissions,sY as pageCapture,lY as omnibox,nY as offscreen,OY as notifications,QY as messages,pY as management,DY as isContentScript,KY as isBackgroundScript,vY as idle,kY as identity,uY as i18n,yY as history,CY as getBrowserType,oY as fontSettings,xY as downloads,wY as devtools,eY as default,PY as declarativeNetRequest,LY as cookies,qY as contextMenus,mY as commands,IY as browsingData,gY as bookmarks,SY as alarms,hY as action,V as Qevo};
